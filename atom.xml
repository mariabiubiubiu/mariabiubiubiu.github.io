<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mario</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-16T12:15:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mario MU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis 深度冒险 读书笔记（四）原理</title>
    <link href="http://yoursite.com/2019/02/16/redis-%E6%B7%B1%E5%BA%A6%E5%86%92%E9%99%A9-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/16/redis-深度冒险-读书笔记（四）原理/</id>
    <published>2019-02-16T08:04:19.000Z</published>
    <updated>2019-02-16T12:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>redis 原理：</p><p>原理 1:鞭辟入里 —— 线程 IO 模型 </p><p>Redis 是个单线程程序!这点必须铭记。 （redis，node.js，nginx都是）这个线程要同时负责多个客户端套接字的并发读写操作 和内存数据结构的逻辑读写 </p><p>Redis 单线程为什么还能这么快? 所有的运算都是内存级别的运算 </p><p>Redis 单线程如何处理那么多的并发客户端连接?   多路复用，select 系列的事件轮询 API ， 非阻塞IO<br>下面分别解释一下：<br>非阻塞 IO<br>非阻塞 IO 在套接字对象上 供了一个选项 Non_Blocking，当这个选项打开时，读写方 法不会阻塞，而是能读多少读多少，能写多少写多少。<br>事件轮询 (多路复用)<br>非阻塞 IO 有个问题，那就是线程要读数据，结果读了一部分就返回了，线程如何知道 何时才应该继续读。 </p><p>￼</p><p>事件轮询 API 就是用来解决这个问题的，最简单的事件轮询 API 是 select 函数，它是 操作系统 供给用户程序的 API。<br>输入是读写 述符列表 read_fds &amp; write_fds<br>输出是与之 对应的可读可写事件。同时还 供了一个 timeout 参数， </p><p>read_events, write_events = select(read_fds, write_fds, timeout) for event in read_events:<br>handle_read(event.fd) for event in write_events:<br>handle_write(event.fd) handle_others() # 处理其它事情，如定时任务等 </p><p>指令队列<br>Redis 会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行 顺序处理，先到先服务。 </p><p>响应队列<br>每个客户端套接字关联一个响应队列 ，<br>Redis 服务器通过响应队列来将 指令的返回结果回复给客户端。 </p><p>定时任务<br>服务器处理要响应 IO 事件外，还要处理其它事情。比如定时任务就是非常重要的一件 事。如果线程阻塞在 select 系统调用上，定时任务将无法得到准时调度。<br>Redis 的定时任务会记录在一个称为最小堆的数据结构中。这个堆中，最快要执行的任 务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处 理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是 select 系统调 用的 timeout 参数。因为 Redis 知道未来 timeout 时间内，没有其它定时任务需要处理，所以 可以安心睡眠 timeout 的时间。 </p><p>原理 2:交头接耳 —— 通信协议<br>RESP 是 Redis 序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简 单，解析性能极好。<br>Redis 协议将传输的结构数据分为 5 种最小单元类型，单元结束时统一加上回车换行符<br>号\r\n。<br>1、单行字符串 以 + 符号开头。<br>2、多行字符串 以 $ 符号开头，后跟字符串长度。<br>3、整数值 以 : 符号开头，后跟整数的字符串形式。<br>4、错误消息 以 - 符号开头。 5、数组 以 * 号开头，后跟数组的长度。 </p><p>客户端 -&gt; 服务器<br>客户端向服务器发送的指令只有一种格式，多行字符串数组。比如一个简单的 set 指令 set author codehole 会被序列化成下面的字符串。<br>“*3\r\n$3\r\nset\r\n$6\r\nauthor\r\n$8\r\ncodehole\r\n “</p><p>服务器 -&gt; 客户端 </p><p>原理 3:未雨绸缪 —— 持久化 </p><p>Redis 的持久化机制有两种，<br>第一种是快照，快照是内存数据的二进制序列化形式，在存储上非常紧凑</p><p>第二种是 AOF 日志。 AOF 日志记录的是内存数据修改的指令记录文本。AOF 日志在长期的运行过程中会 变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长。 所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。<br>快照是一次全量备份，AOF 日志是连续的增量备份。 </p><p>快照：<br>Redis 使用操作系统的多进程 COW(Copy On Write) 机制来实现快照持久化，这个机制 很有意思，也很少人知道。多进程 COW 也是鉴定程序员知识广度的一个重要指标。 </p><p>fork(多进程)<br>Redis 在持久化时会调用 glibc 的函数 fork 产生一个子进程，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pid = os.fork() if pid &gt; 0: </span><br><span class="line">handle_client_requests() if pid == 0: </span><br><span class="line">handle_snapshot_write() if pid &lt; 0: </span><br><span class="line"># fork error</span><br></pre></td></tr></table></figure></p><p>子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读<br>取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存<br>数据结构进行不间断的修改。<br>这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操 作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复 制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的， 还是进程产生时那一瞬间的数据。 </p><p>AOF 日志存储的是 Redis 服务器的顺序指令序列，AOF 日志只记录对内存进行修改的 指令记录。  「重放」，来恢复 Redis 当前实例的内 存数据结构的状态。 Aof原理是 先存到磁盘，然后再执行指令。 </p><p>fsync<br>Linux 的 glibc 供了 fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁 盘<br>Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可 以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到升。 </p><p>原理 4:雷厉风行 —— 管道 </p><p>其实这个是由客户端提供的</p><p>客户端通过对管道中的指令列表改变读写顺序就可以大 幅节省 IO 时间。管道中指令越多，效果越好。 、</p><p>这是我使用redis-benchmark 来进行测试的图，-P 参数，它表示单个管道内并行的请求数量， </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mario-tututu:demo mu$  redis-benchmark -t set -q</span><br><span class="line">SET: 48076.93 requests per second</span><br><span class="line"></span><br><span class="line">mario-tututu:demo mu$  redis-benchmark -t set -q -P 2</span><br><span class="line">SET: 96711.80 requests per second</span><br><span class="line"></span><br><span class="line">mario-tututu:demo mu$  redis-benchmark -t set -q -P 3</span><br><span class="line">SET: 125313.29 requests per second</span><br><span class="line"></span><br><span class="line">mario-tututu:demo mu$  redis-benchmark -t set -q -P 4</span><br><span class="line">SET: 156006.25 requests per second</span><br><span class="line"></span><br><span class="line">mario-tututu:demo mu$  redis-benchmark -t set -q -P 5</span><br><span class="line">SET: 177619.89 requests per second</span><br><span class="line"></span><br><span class="line">mario-tututu:demo mu$  redis-benchmark -t set -q -P 6</span><br><span class="line">SET: 198807.16 requests per second</span><br><span class="line"></span><br><span class="line">mario-tututu:demo mu$  redis-benchmark -t set -q -P 7</span><br><span class="line">SET: 220264.31 requests per second</span><br></pre></td></tr></table></figure><p>现在做一次请求交互的流程：</p><p>￼<br>1、客户端进程调用 write 将消息写到操作系统内核。为套接字分配的发送缓冲 send buffer。<br>2、客户端操作系统内核 将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到服务器的网卡。<br>3、服务器操作系统内核 将网卡的数据放到内核为 套接字分配的接收缓冲 recv buffer。<br>4、服务器进程调用 read 从接收缓冲中取出消息进行处理。 5、服务器进程调用 write 将响应消息写到内核为套接字分配的发送缓冲 send buffer。<br>6、服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到客户端的网卡。<br>7、客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲 recv buffer。<br>8、客户端进程调用 read 从接收缓冲中取出消息返回给上层业务逻辑进行处理。<br>9、结束。 </p><p>原理 5:同舟共济 —— 事务 </p><p>multi 指示事务的开始，<br>exec 指示事务的执行，<br>discard 指示事务的丢弃。 </p><p>pipe = redis.pipeline(transaction=true)<br>pipe.multi() pipe.incr(“books”) pipe.incr(“books”)<br>values = pipe.execute() </p><p>这就会出现并发问题，因为有多个客户端会并发进行操作。<br>我们可以通过 Redis 的分布 式锁来避免冲突，这是一个很好的解决方案。<br>分布式锁是一种悲观锁，那是不是可以使用乐 观锁的方式来解决冲突呢? </p><p>watch 会在事务开始之前盯住 1 个或多个关键变量，当事务执行时，也就是服务器收到 了 exec 指令要顺序执行缓存的事务队列时，Redis 会检查关键变量自 watch 之后，是否被 修改了 (包括当前事务所在的客户端)。 </p><p>注意：Redis 禁止在 multi 和 exec 之间执行 watch 指令，而必须在 multi 之前做好盯住关键 变量，否则会出错。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis 原理：&lt;/p&gt;
&lt;p&gt;原理 1:鞭辟入里 —— 线程 IO 模型 &lt;/p&gt;
&lt;p&gt;Redis 是个单线程程序!这点必须铭记。 （redis，node.js，nginx都是）这个线程要同时负责多个客户端套接字的并发读写操作 和内存数据结构的逻辑读写 &lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis 深度冒险 读书笔记（三）</title>
    <link href="http://yoursite.com/2019/02/16/redis-%E6%B7%B1%E5%BA%A6%E5%86%92%E9%99%A9-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/16/redis-深度冒险-读书笔记（三）/</id>
    <published>2019-02-16T08:01:55.000Z</published>
    <updated>2019-02-16T08:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 应用（三）“</p><p>应用一：<br>漏斗限流 </p><a id="more"></a><p>漏斗的剩余空间就代表着当前行为可以持续进行的数量，漏嘴的流水速率代表着<br>系统允许该行为的最大频率。下面我们使用代码来 述单机漏斗算法。</p><p>核心算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf8</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Funnel(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, capacity, leaking_rate):</span><br><span class="line">        self.capacity = capacity # 漏斗容量</span><br><span class="line">        self.leaking_rate = leaking_rate # 漏嘴流水速率</span><br><span class="line">        self.left_quota = capacity  # 漏斗剩余空间</span><br><span class="line">        self.leaking_ts = time.time() # 上一次漏水时间</span><br><span class="line">        self.left_quota = capacity  # 漏斗剩余空间 self.leaking_ts = time.time() # 上一次漏水时间</span><br><span class="line"></span><br><span class="line">    def make_space(self):</span><br><span class="line">        now_ts = time.time()</span><br><span class="line"></span><br><span class="line">        delta_ts = now_ts - self.leaking_ts  # 距离上一次漏水过去了多久</span><br><span class="line">        delta_quota = delta_ts * self.leaking_rate # 又可以腾出不少空间了</span><br><span class="line">        if delta_quota &lt; 1: # 腾的空间太少，那就等下次吧</span><br><span class="line">            return</span><br><span class="line">        self.left_quota += delta_quota  # 增加剩余空间</span><br><span class="line">        self.leaking_ts = now_ts # 记录漏水时间</span><br><span class="line">        if self.left_quota &gt; self.capacity:  # 剩余空间不得高于容量</span><br><span class="line">            self.left_quota = self.capacity</span><br><span class="line"></span><br><span class="line">    def watering(self, quota):</span><br><span class="line">        self.make_space()</span><br><span class="line"></span><br><span class="line">        if self.left_quota &gt;= quota:</span><br><span class="line">            self.left_quota -= quota</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">funnels = &#123;&#125;  # 所有的漏斗判断剩余空间是否足够</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># capacity 漏斗容量</span><br><span class="line"># leaking_rate 漏嘴流水速率 quota/s</span><br><span class="line">def is_action_allowed(user_id, action_key, capacity, leaking_rate):</span><br><span class="line">    key = &apos;%s:%s&apos; % (user_id, action_key)</span><br><span class="line">    funnel = funnels.get(key)</span><br><span class="line">    if not funnel:</span><br><span class="line">        funnel = Funnel(capacity, leaking_rate)</span><br><span class="line">        funnels[key] = funnel</span><br><span class="line">    return funnel.watering(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">    print is_action_allowed(&apos;laoqian&apos;, &apos;reply&apos;, 15, 0.5)</span><br></pre></td></tr></table></figure><p>Funnel 对象的 make_space 方法是漏斗算法的核心，其在每次灌水前都会被调用以触发 漏水，给漏斗腾出空间来。能腾出多少空间取决于过去了多久以及流水的速率。Funnel 对象 占据的空间大小不再和行为的频率成正比，它的空间占用是一个常量。 </p><p>我们观察 Funnel 对象的几个字段，我们发现可以将 Funnel 对象的内容按字段存储到一 个 hash 结构中，灌水的时候将 hash 结构的字段取出来进行逻辑运算后，再将新值回填到 hash 结构中就完成了一次行为频度的检测。<br>我们无法保证整个过程的原子性。从 hash 结构中取值，然后在内存里 运算，再回填到 hash 结构，这三个过程无法原子化， </p><p>Redis 4.0 供了一个限流 Redis 模块，它叫 redis-cell。 </p><p>举例：<br>cl.throttle laoqian:reply 15 30 60<br>1) (integer) 0<br>2) (integer) 15<br>3) (integer) 14<br>4) (integer) -1<br>5) (integer) 2 </p><h1 id="0-表示允许，1-表示拒绝"><a href="#0-表示允许，1-表示拒绝" class="headerlink" title="0 表示允许，1 表示拒绝"></a>0 表示允许，1 表示拒绝</h1><h1 id="漏斗容量-capacity"><a href="#漏斗容量-capacity" class="headerlink" title="漏斗容量 capacity"></a>漏斗容量 capacity</h1><h1 id="漏斗剩余空间-left-quota"><a href="#漏斗剩余空间-left-quota" class="headerlink" title="漏斗剩余空间 left_quota"></a>漏斗剩余空间 left_quota</h1><h1 id="如果拒绝了，需要多长时间后再试-漏斗有空间了，单位秒"><a href="#如果拒绝了，需要多长时间后再试-漏斗有空间了，单位秒" class="headerlink" title="如果拒绝了，需要多长时间后再试(漏斗有空间了，单位秒)"></a>如果拒绝了，需要多长时间后再试(漏斗有空间了，单位秒)</h1><h1 id="多长时间后，漏斗完全空出来-left-quota-capacity，单位秒"><a href="#多长时间后，漏斗完全空出来-left-quota-capacity，单位秒" class="headerlink" title="多长时间后，漏斗完全空出来(left_quota==capacity，单位秒)"></a>多长时间后，漏斗完全空出来(left_quota==capacity，单位秒)</h1><p>上面这个指令的意思是允许「用户老钱回复行为」的频率为每 60s 最多 30 次(漏水速 率)，漏斗的初始容量为 15，也就是说一开始可以连续回复 15 个帖子，然后才开始受漏水 速率的影响。我们看到这个指令中漏水速率变成了 2 个参数，替代了之前的单个浮点数。用 两个参数相除的结果来表达漏水速率相对单个浮点数要更加直观一些。 </p><p>应用二：GeoHash（附近的人～～）</p><p>用数据库来算附近的人 </p><p>经度范围 (-180, 180]，纬度范围 (-90, 90]，  然后勾股定理算一下就完事儿了。</p><p>GeoHash 算法将二维的经纬度数据映射到一维的整数，这样所有的元素都将在挂载到一 条线上， </p><p>映射算法是这样：</p><p>那这个映射算法具体是怎样的呢?它将整个地球看成一个二维平面，然后划分成了一系 列正方形的方格，就好比围棋棋盘。所有的地图元素坐标都将放置于唯一的方格中。方格越 小，坐标越精确。然后对这些方格进行整数编码，越是靠近的方格编码越是接近。那如何编 码呢?一个最简单的方案就是切蛋糕法。设想一个正方形的蛋糕摆在你面前，二刀下去均分 分成四块小正方形，这四个小正方形可以分别标记为 00,01,10,11 四个二进制整数。然后对 每一个小正方形继续用二刀法切割一下，这时每个小小正方形就可以使用 4bit 的二进制整数 予以表示。然后继续切下去，正方形就会越来越小，二进制整数也会越来越长，精确度就会 越来越高。 </p><p>在使用 Redis 进行 Geo 查询时，我们要时刻想到它的内部结构实际上只是一个 zset(skiplist)。通过 zset 的 score 排序就可以得到坐标附近的其它元素 (实际情况要复杂一 些，不过这样理解足够了)，通过将 score 还原成坐标值就可以得到元素的原始坐标。 </p><p>例子：</p><p>geoadd 指令携带集合名称以及多个经纬度名称三元组，注意这里可以加入多个三元组<br>geoadd company 116.48105 39.996794 juejin </p><p>geodist 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。<br>geodist company juejin ireader km </p><p>geopos 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。<br>geopos company juejin </p><p>geohash 可以获取元素的经纬度编码字符串，上面已经 到，它是 base32 编码。 你可 以使用这个编码值去 <a href="http://geohash.org/${hash}中进行直接定位，它是" target="_blank" rel="noopener">http://geohash.org/${hash}中进行直接定位，它是</a> geohash 的标准编码 值。<br>geohash company ireader </p><p>georadiusbymember 指令是最为关键的指令，它可以用来查询指定元素附近的其它元 素，它的参数非常复杂。<br>geohash company ireader<br>得出来的value<br>wx4g52e1ce0<br>可以通过此网站进行校对 是否正确<br><a href="http://geohash.org/wx4g52e1ce0" target="_blank" rel="noopener">http://geohash.org/wx4g52e1ce0</a> </p><p>georadiusbymember 指令是最为关键的指令，它可以用来查询指定元素附近的其它元 素，它的参数非常复杂。 </p><h1 id="范围-20-公里以内最多-3-个元素按距离正排，它不会排除自身"><a href="#范围-20-公里以内最多-3-个元素按距离正排，它不会排除自身" class="headerlink" title="范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身"></a>范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身</h1><p>127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc </p><h1 id="范围-20-公里以内最多-3-个元素按距离倒排"><a href="#范围-20-公里以内最多-3-个元素按距离倒排" class="headerlink" title="范围 20 公里以内最多 3 个元素按距离倒排"></a>范围 20 公里以内最多 3 个元素按距离倒排</h1><p>127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 desc<br>1) “jd” 2) “meituan” 3) “juejin” </p><h1 id="三个可选参数-withcoord-withdist-withhash-用来携带附加参数-withdist-很有用，它可以用来显示距离"><a href="#三个可选参数-withcoord-withdist-withhash-用来携带附加参数-withdist-很有用，它可以用来显示距离" class="headerlink" title="三个可选参数 withcoord withdist withhash 用来携带附加参数# withdist 很有用，它可以用来显示距离"></a>三个可选参数 withcoord withdist withhash 用来携带附加参数# withdist 很有用，它可以用来显示距离</h1><p>127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc </p><p>注意：<br>在一个地图应用中，车的数据、餐馆的数据、人的数据可能会有百万千万条，如果使用 Redis 的 Geo 数据结构，它们将全部放在一个 zset 集合中。在 Redis 的集群环境中，集合 可能会从一个节点迁移到另一个节点，如果单个 key 的数据过大，会对集群的迁移工作造成 较大的影响，在集群环境中单个 key 对应的数据量不宜超过 1M，否则会导致集群迁移出现 卡顿现象，影响线上服务的正常运行。<br>所以，这里建议 Geo 的数据使用单独的 Redis 实例部署，不使用集群环境。<br>如果数据量过亿甚至更大，就需要对 Geo 数据进行拆分，按国家拆分、按省拆分，按 市拆分，在人口特大城市甚至可以按区拆分。这样就可以显著降低单个 zset 集合的大小。 </p><p>应用三。Scan </p><p>需求：有时候需要从 Redis 实例成千上万的 key 中找出特定 前缀的 key 列表来手动处理数据 </p><p>Keys 可以通过正则满足这个需求但是 有两个比较明显的问题：</p><p>1，没有 offset、limit 参数<br>2，keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令<br>就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，因为<br>Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才<br>可以继续。 </p><p>Redis 添加scan 命令 解决这个问题</p><p>优点：<br>1，通过游标完成，不会阻塞<br>2，提供 limit 参数  提供返回结果的最大条数<br>3，也提供模式匹配的功能<br>4，服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;<br>需要注意的点：<br>1，返回的结果可能会有重复，需要客户端去重复，这点非常重要;<br>2，遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;<br>3，单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零; </p><p>例子：<br>scan 参数 供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三<br>个是遍历的 limit hint。<br>第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为<br>下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 </p><p>scan 0 match key99* count 1000 </p><p>原理现在不想仔细看了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 应用（三）“&lt;/p&gt;
&lt;p&gt;应用一：&lt;br&gt;漏斗限流 &lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis深度历险 读书笔记（二)</title>
    <link href="http://yoursite.com/2019/02/15/redis%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/02/15/redis深度历险-读书笔记（二/</id>
    <published>2019-02-15T12:09:52.000Z</published>
    <updated>2019-02-15T12:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Redis 应用#<br><a id="more"></a></p><p>##应用3:  位图<br>提出了签到问题，如果存储365个这种数据，存储量巨大</p><p>为了解决这个问题，Redis 供了位图数据结构，这样每天的签到记录只占据一个位， 365 天就是 365 个位，46 个字节 (一个稍长一点的字符串) 就可以完全容纳下，这就大大 节约了存储空间。 </p><p>位图其实就是普通字符串 也就是 byte 数组 </p><p>setbit  s 1 1来设置位数</p><p>可以多次setbit 一次get 来获取具体字符串</p><p>getbitw  s 1 获取第几位</p><p>另外<br>Redis 供了位图统计指令 bitcount 和位图查找指令 bitpos，bitcount 用来统计指定位 置范围内 1 的个数，bitpos 用来查找指定范围内出现的第一个 0 或 1。 </p><p>bitcount w 一共有多少位 </p><p>bitcount w 1 10。1-10位一共多少个1</p><p>一次进行多个位的操作。 bitfield 有三个子指令，分别是 get/set/incrby<br>bitfield 有三个子指令，分别是 get/set/incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果 超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个子指令。<br>举个例子：<br>bitfield w get u4 0   # 从第一个位开始取 4 个位，结果是无符号数 (u)。<br>bitfield w get i3 2    # 从第三个位开始取 3 个位，结果是有符号数 (i)<br>bitfield w incrby u4 2 1 # 从第三个位开始，对接下来的 4 位无符号数 +1 </p><p>##应用四：HyperLogLog<br>（如果你负责开发维护一个大型的 网站，有一天老板找产品经理要网站每个网页每天的 UV 数据，然后让你来开发这个统计模 块，你会如何实现? ）<br>网站流量统计之UV(Unique Visitor)：独立访客，将每个独立上网电脑（以cookie为依据）视为一位访客，一天之内（00:00-24:00），访问您网站的访客数量。一天之内相同cookie的访问只被计算1次。<br>网站流量统计之PV（Page View）：访问量,即页面浏览量或者点击量,用户每次对网站的访问均被记录1次。用户对同一页面的多次访问，访问量值累计</p><p>简单解决：简单的方案，那就是为每一个页面一个独立的 set 集合来存储所 有当天访问过此页面的用户 ID。当一个请求过来时，我们使用 sadd 将用户 ID 塞进去就可 以了。通过 scard 可以取出这个集合的大小，这个数字就是这个页面的 UV 数据。 </p><p>但是这样占据空间较大</p><p>HyperLogLog 供不精确的去重计数方案，虽然不精确但是也不是非常不 精确，标准误差是 0.81%，这样的精确度已经可以满足上面的 UV 统计需求了。<br>使用pfadd 和pfcount 来操作</p><p>用python 测试了一下： <br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8 import redis_test</span><br><span class="line">import redis</span><br><span class="line"></span><br><span class="line">client = redis.Redis()</span><br><span class="line"></span><br><span class="line">for i in range(10000000):</span><br><span class="line">    client.pfadd(&quot;codehole&quot;, &quot;user%d&quot; % i)</span><br><span class="line">    total = client.pfcount(&quot;codehole&quot;)</span><br><span class="line">    if total != i+1:</span><br><span class="line">        print total, i+1</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></p><p>误差是有的。根据具体情况 看是否可以接受</p><p>还提供了第三个指令 pfmerge，用于 将多个 pf 计数值累加在一起形成一个新的 pf 值。 </p><p>需要注意的是：它需要占据 一定 12k 的存储空间，所以它不适合统计单个用户相关的数据。 </p><p>可以解决 很多精确度不高的统计需求。<br>具体实现没有仔细看：如果有机会（算了，我真的现在不想看了。。。）</p><p>##应用五：布隆过滤器 </p><p>比如我们在使用新闻客户端看新闻时，它会给我们不停地推荐新的内<br>容，它每次推荐时要去重，去掉那些已经看过的内容。问题来了，新闻客户端推荐系统如何<br>实现推送去重的?</p><p>布隆过滤器 (Bloom Filter) 闪亮登场了，它就是专门用来解决这种去重问题的。 它在起到去重的同时，在空间上还能节省 90% 以上，只是稍微有那么点不精确，也就是有 一定的误判概率。<br>当布隆过滤器说某个值存在时，这个值可能不存在;   当它说不存在时，那就肯定不存 在。 </p><p>需要安装插件才可以使用：</p><p>布隆过滤器有二个基本指令，bf.add 添加元素，bf.exists 查询元素是否存在，它的用法 和 set 集合的 sadd 和 sismember 差不多。注意 bf.add 只能一次添加一个元素，如果想要 一次添加多个，就需要用到 bf.madd 指令。同样如果需要一次查询多个元素是否存在，就需 要用到 bf.mexists 指令。 </p><p>Redis 其实还 供了自定义参数的布隆过滤器，需要我们在 add 之前使用 bf.reserve 指令显式创建。如果对应的 key 已经存在，bf.reserve 会报错。bf.reserve 有三个参数，分别<br>是 key, error_rate 和 initial_size。错误率越低，需要的空间越大。initial_size 参数表示预计放 入的元素数量，当实际数量超出这个数值时，误判率会上升。<br>所以需要 前设置一个较大的数值避免超出导致误判率升高。如果不使用 bf.reserve，默 认的 error_rate 是 0.01，默认的 initial_size 是 100。 </p><p>##本次学习的最后一个应用： 限流器</p><p>系统要限定用户的某个行为在指定的时间里 只能允许发生 N 次， </p><p>这个限流需求中存在一个滑动时间窗口，想想 zset 数据结构的 score 值，是不是可以 通过 score 来圈出这个时间窗口来。<br>那这个 zset 的 value 填什么比较合适呢?它只需要保证唯一性即可，用 uuid 会 比较浪费空间，那就改用毫秒时间戳吧。 </p><p> 把key当作行为 每一个行为创建一个key<br>Value 只需要保证时间的唯一性即可。我们使用 毫秒的时间戳<br>Score 来设置一个滑动窗口，也使用 毫秒的时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import redis</span><br><span class="line">client = redis.StrictRedis()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def is_action_allowed(user_id, action_key, period, max_count):</span><br><span class="line">    key = &apos;hist:%s:%s&apos; % (user_id, action_key)</span><br><span class="line">    now_ts = int(time.time() * 1000)</span><br><span class="line">    # 毫秒时间戳</span><br><span class="line">    with client.pipeline() as pipe:</span><br><span class="line">        # client 是 StrictRedis 实例</span><br><span class="line">        # 记录行为</span><br><span class="line">        pipe.zadd(key, now_ts, now_ts)</span><br><span class="line">        # value 和 score 都使用毫秒时间戳</span><br><span class="line">        #  移除时间窗口之前的行为记录，剩下的都是时间窗口内的</span><br><span class="line">        pipe.zremrangebyscore(key, 0, now_ts - period * 1000)</span><br><span class="line">        # 获取窗口内的行为数量</span><br><span class="line">        pipe.zcard(key)</span><br><span class="line"></span><br><span class="line">        # 设置 zset 过期时间，避免冷用户持续占用内存 # 过期时间应该等于时间窗口的长度，再多宽限 1s</span><br><span class="line">        pipe.expire(key, period + 1)</span><br><span class="line">        # 批量执行</span><br><span class="line">        _, _, current_count, _ = pipe.execute()</span><br><span class="line">    # 比较数量是否超标</span><br><span class="line">    return current_count &lt;= max_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">    print is_action_allowed(&quot;laoqian&quot;, &quot;reply&quot;, 60, 5)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Redis 应用#&lt;br&gt;
    
    </summary>
    
    
      <category term="reids" scheme="http://yoursite.com/tags/reids/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>wrk 性能测试</title>
    <link href="http://yoursite.com/2019/02/15/wrk-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/02/15/wrk-性能测试/</id>
    <published>2019-02-15T09:22:35.000Z</published>
    <updated>2019-02-15T09:23:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>编写完成了go 语言项目后 需要对具体的项目和python进行一个基本性能测试。<br>之前了解过jmeter，和 ab<br><a id="more"></a></p><p>但是ab有一个问题 是希望结果固定才算成功（好像是这样）</p><p>因为这个 选择了wrk 进行性能测试，效果看起来也不错 简单易懂</p><p>安装过程比较简单 编译就行了</p><p>···<br>git clone <a href="https://github.com/wg/wrk.git" target="_blank" rel="noopener">https://github.com/wg/wrk.git</a><br>cd wrk<br>make<br>···</p><p>安装前需要安装 openssl</p><p>sudo yum install  openssl-devel </p><p>做一次简单的测试<br>···<br>wrk -t12 -c100<br>···</p><p>···<br>Running 30s test @ <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br>12 threads and 100 connections<br>  Thread Stats   Avg      Stdev     Max   +/- Stdev<br>    Latency   538.64ms  368.66ms   1.99s    77.33%<br>    Req/Sec    15.62     10.28    80.00     75.35%<br>5073 requests in 30.09s, 75.28MB read<br>  Socket errors: connect 0, read 5, write 0, timeout 64<br>Requests/sec:    168.59<br>Transfer/sec:      2.50MB<br>···</p><p>另外加上post 如何测试</p><p>编写post的lua文件</p><p>···<br>wrk.method = “POST”<br>wrk.body   = “foo=bar&amp;baz=quux”<br>wrk.headers[“Content-Type”] = “application/x-www-form-urlencoded”<br>···</p><p>···<br>wrk -t12 -c100 -d30s -T30s –script=post.lua –latency <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br>···</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写完成了go 语言项目后 需要对具体的项目和python进行一个基本性能测试。&lt;br&gt;之前了解过jmeter，和 ab&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>redis 深度历险读书笔记（一）</title>
    <link href="http://yoursite.com/2019/02/15/redis-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/15/redis-深度历险读书笔记（一）/</id>
    <published>2019-02-15T06:08:16.000Z</published>
    <updated>2019-02-15T06:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一章节<br><a id="more"></a><br>redis 学习：</p><p>string (字符串)、list (列表)、set (集合)、hash (哈 希) 和 zset (有序集合)。 </p><p>String 一个常见的用途就是缓存用户信息。我们将用户信息结构体 使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。 </p><p>Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字 符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时， 扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是 字符串最大长度为 512M。 </p><p>Set/get/del/ mset/ mget/expire／setex = set + expire／setnx。不存在 则创建／incrby/</p><p>mget/mset  是批量获取</p><p>Incrb/Incrby 还可以对它进行自增操作。自增是有范围的，它的范围是 signed long </p><p>list (列表)<br>Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。<br>  当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。<br>Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符 串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。 </p><p>右边进左边出:队列  :    rpush/llen/lpop/lpush</p><p>右边进右边出:栈  :rpush/rpop/rpush</p><p>慢操作：lrange lindex </p><p>hash (字典)<br>Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞 时，就会将碰撞的元素使用链表串接起来。 </p><p>￼<br>hset/hget/</p><p>hset 第一次操作返回1，更新操作返回0</p><p>hgetall # entries()，key 和 value 间隔出现</p><p>hlen</p><p>hmset 插入多条数据</p><p>hincrby  自增</p><p>set (集合)<br>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的 内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。 </p><p>当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。 set 结构可以用来 存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。 </p><p>sadd。</p><p>smembers 查看所有的。sismember  查看指定member<br>scard 获取长度<br>spop 弹出一个</p><hr><p>zset (有序列表)<br>zset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结 构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权 重。它的内部实现用的是一种叫着「跳跃列表」的数据结构。 </p><p>应用：<br>zset 可以用来存 粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间 进行排序。<br>zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们 可以对成绩按分数进行排序就可以得到他的名次。 </p><p>命令：<br>zadd + key + score + value<br>zrange books 0 -1 # 按 score 排序列出，参数区间为排名范围<br>zrevrange books 0 -1 # 按 score 逆序列出，参数区间为排名范围<br>zrangebyscore books 0 8.91 # 根据分值区间遍历 zset<br> zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返 回分值。inf 代表 infinite，无穷大的意思。 </p><p>zrem books “java concurrency” # 删除 value </p><p>zcard  计数<br>zscore 获取指定的分值<br>zrank 排名 从0开始 从小到大</p><p>结构解析：</p><p>zset 要支持随机的插入和删除 </p><hr><p>容器型数据结构的通用规则<br>list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则: 1、create if not exists 如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，<br>Redis 就会自动创建一个，然后再 rpush 进去新元素。2、drop if no elements 如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一<br>个元素，列表就消失了。 </p><hr><p>应用：分布式锁</p><p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占 时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。<br>占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用 完了，再调用 del 指令释放茅坑。<br>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样 就会陷入死锁，锁永远得不到释放。<br>于是我们在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也 可以保证 5 秒之后锁会自动释放。<br>但是我们又遇见一个问题 还是没有办法 保证set 和设置过期时间 是一起执行的</p><p>如果你需要使用分布式锁， 意味着你不能仅仅使用 Jedis 或者 redis-py 就行了，还得引入分布式锁的 library。<br>set lock:codehole true ex 5 nx OK<br>del lock:codehole<br>但是这样害怕 逻辑执行过长</p><p>有一个更加安全的方案是为 set 指令的 value 参数设置为一个随机数，释放锁时先匹配 随机数是否一致，然后再删除 key。但是匹配 value 和删除 key 不是一个原子操作，Redis 也 没有提供类似于 delifequals 这样的指令，这就需要使用 Lua 脚本来处理了，因为 Lua 脚本可 以保证连续多个指令的原子性执行。 </p><hr><p>应用：延时队列</p><p>对于那些只有一组消费者的消息队列，使用 Redis 就可以非常轻松的搞定。<br>Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用rpush/lpush操作入队列， 使用 lpop 和 rpop 来出队列<br>使用过程中有几个问题需要注意：<br>1，队列空了怎么办?<br>当list为空了，就会不停的pop，<br>只需要要线程睡一秒就可以了</p><p>2，队列延迟<br>睡眠会导致消息的延迟增大 </p><p>使用：blpop/brpop。   这两个指令的前缀字符 b 代表的是 blocking，也就是阻塞读 </p><p>3，空闲连接自动断开 </p><p>如果线程一直阻塞在哪里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般<br>会主动断开连接，减少闲置资源占用。这个时候 blpop/brpop 会抛出异常来。 所以编写客户端消费者的时候要小心，注意捕获异常，还要重试。… </p><p>4， 锁冲突处理 </p><p>遇到加锁失败怎么办？<br>1、直接抛出异常，通知用户稍后重试;<br>2、sleep 一会再重试;<br>3、将请求转移至延时队列，过一会再试;<br>下面介绍一下。延时队列的实现。</p><p>使用zset(有序列表) 来实现。我们将消息序列化成一个字符串作 为 zset 的 value，这个消息的到期处理时间作为 score，然后用多个线程轮询 zset 获取到期 的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处 理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。 </p><p>···<br>def delay(msg):     msg.id = str(uuid.uuid4()) # 保证 value 值唯一 value = json.dumps(msg)     retry_ts = time.time() + 5 # 5 秒后重试 redis.zadd(“delay-queue”, retry_ts, value)<br>def loop():<br>     while True: # 最多取 1 条<br>        values = redis.zrangebyscore(“delay-queue”, 0, time.time(), start=0, num=1)<br>            if not values:<br>                time.sleep(1) # 延时队列空的，休息 1s<br>                continue         value = values[0] # 拿第一条，也只有一条<br>        success = redis.zrem(“delay-queue”, value) # 从消息队列中移除该消息<br>        if success: # 因为有多进程并发的可能，最终只会有一个进程可以抢到消息<br>            msg = json.loads(value)<br>            handle_msg(msg)<br>····</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一章节&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>mac的homebrew 安装路径 + redis Failed opening the RDB file dump.rdb</title>
    <link href="http://yoursite.com/2019/02/15/mac-%E7%9A%84-homebrew-%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/02/15/mac-的-homebrew-安装路径/</id>
    <published>2019-02-15T03:16:32.000Z</published>
    <updated>2019-02-15T03:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装redis 后 一直报错：Failed opening the RDB file dump.rdb<br><a id="more"></a><br>猜测是没有权限，想找到redis的安装目录，但是安装是实用的 brew install安装的</p><p>homebrew在安装时,默认把redis.conf文件放到了 /usr/local/etc/redis.conf</p><p>但是我想找到 redis的具体安装目录<br>然后发现了这个命令</p><p>brew –prefix<br>/usr/local/opt/redis</p><p>brew config | grep HOMEBREW</p><p>找到 /usr/local/opt/redis 后 使用chmod 755 来改变权限后 再次启动依然报错。</p><p>最后解决办法。。sudo<br>（好了 我知道这篇文章没什么意思哈哈哈哈，就是记录一下学习的 过程）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装redis 后 一直报错：Failed opening the RDB file dump.rdb&lt;br&gt;
    
    </summary>
    
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>golang json 遇到的坑</title>
    <link href="http://yoursite.com/2019/02/15/golang-json-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2019/02/15/golang-json-遇到的坑/</id>
    <published>2019-02-15T02:58:19.000Z</published>
    <updated>2019-02-15T03:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>遇到了一个坑 使用golang bindjson的时候 无论如何也获取不到数据<br><a id="more"></a></p><p>后来发现是struct内的大小写问题</p><p>但是好奇 大小写只是控制public private 的啊，为什么在同一个包访问会导致我访问不了呢？</p><p>最后发现是涉及到反射的后 不能访问。做了一个简单测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Point struct &#123;</span><br><span class="line">X int</span><br><span class="line">Y string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">po := Point&#123;3, &quot;ddd&quot;&#125;</span><br><span class="line">s := reflect.ValueOf(&amp;po).Elem()</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">f := s.Field(i)</span><br><span class="line">fmt.Printf(&quot; %s %v \n&quot;, f.Type(), f.Interface())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">int 3 </span><br><span class="line">string ddd</span><br></pre></td></tr></table></figure><p>当把xy改为小写后 则不能访问，猜测这也就是不能访问的原因的吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到了一个坑 使用golang bindjson的时候 无论如何也获取不到数据&lt;br&gt;
    
    </summary>
    
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>微服务中的api网关</title>
    <link href="http://yoursite.com/2018/10/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84api%E7%BD%91%E5%85%B3/"/>
    <id>http://yoursite.com/2018/10/08/微服务中的api网关/</id>
    <published>2018-10-08T15:04:05.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天聊天的时候觉得之前做的iam项目有点像微服务中的api网关，发现自己真的对自己做的东西乱乱的 有好多东西没有弄明白，趁着这次 把aip网关记录一下吧。</p><a id="more"></a><p>微服务就是就是将一个大的服务分解成各个不同的小服务。每一个小服务都可以拥有自己的服务器，数据库等，通常以restful APi的形式提供给服务方。</p><p>设想这么一种情况吧。。<br>前端页面需要展示数据，这些数据包含了两部分，两部分分别需要请求不同的微服务。这样如何解决呢？：</p><p>首先要注意几个问题。：<br>服务可能使用了多种协议，因为不同的协议有不同的应场景用，比如可能同时使用 HTTP, AMQP, gRPC 等。<br>服务的划分可能随着时间而变化。<br>服务的实例或者Host+端口可能会动态的变化。</p><p>相应的 服务调用方也有这种问题：</p><p>粗粒度的API，而微服务通常提供的细粒度的API，对于UI来说如果要调用细粒度的api可能需要调用很多次，这是个不小的问题。<br>不同的客户端设备可能需要不同的数据。Web,H5,APP<br>不同设备的网络性能，对于多个api来说，这个访问需要转移的服务端会快得多</p><p>这样 就引出了我们的api网关了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。</span><br><span class="line">API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。</span><br></pre></td></tr></table></figure><p>分别介绍这两种</p><p>单节点 API 网关<br><img src="/img/单节点网关.png" alt="avatar"></p><p>Backends for frontends 网关<br><img src="/img/Backends网关.png" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天聊天的时候觉得之前做的iam项目有点像微服务中的api网关，发现自己真的对自己做的东西乱乱的 有好多东西没有弄明白，趁着这次 把aip网关记录一下吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>golang makefile</title>
    <link href="http://yoursite.com/2018/10/08/golang-makefile/"/>
    <id>http://yoursite.com/2018/10/08/golang-makefile/</id>
    <published>2018-10-08T14:54:29.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>想比与java的编译来说 golang的编译十分简单</p><p>但是。下载依赖包以及测试等工作都需要一些构建技术</p><a id="more"></a><p>我们当然可以使用脚本来写到shell里来执行<br>但是。可读性较差</p><p>我们可以在实际项目中使用makefile来构建代码</p><p>make build: 编译<br>make vendor: 下载依赖<br>make api: 生成协议代码<br>make json: easyjson 代码生成<br>make test: 运行单元测试<br>make benchmark: 运行性能测试<br>make stat: 代码复杂度统计，代码行数统计<br>make clean: 清理 build 目录<br>make deep_clean: 清理所有代码以外的其他文件<br>make third: 下载所有依赖的第三方工具<br>make protoc: 下载 protobuf 工具<br>make glide: 下载 glide 依赖管理工具<br>make golang: 下载 golang 环境<br>make cloc: 下载 cloc 统计工具<br>make gocyclo: 下载 gocyclo 圈复杂度计算工具<br>make easyjson: 下载 easyjson 工具</p><p>举两个实际开发例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">export PATH:=$&#123;PATH&#125;:$&#123;GOPATH&#125;/bin:$(shell pwd)/third/go/bin:$(shell pwd)/third/protobuf/bin:$(shell pwd)/third/cloc-1.76</span><br><span class="line"></span><br><span class="line">.PHONY: all</span><br><span class="line">all: third vendor api json build test stat</span><br><span class="line"></span><br><span class="line">build: cmd/rta_server/*.go internal/*/*.go scripts/version.sh Makefile vendor api json</span><br><span class="line">    @echo &quot;编译&quot;</span><br><span class="line">    @rm -rf build/ &amp;&amp; mkdir -p build/bin/ &amp;&amp; \</span><br><span class="line">    go build -ldflags &quot;-X &apos;main.AppVersion=`sh scripts/version.sh`&apos;&quot; cmd/rta_server/main.go &amp;&amp; \</span><br><span class="line">    mv main build/bin/rta_server &amp;&amp; \</span><br><span class="line">    cp -r configs build/configs/</span><br><span class="line"></span><br><span class="line">vendor: glide.lock glide.yaml</span><br><span class="line">    @echo &quot;下载 golang 依赖&quot;</span><br><span class="line">    glide install</span><br><span class="line"></span><br><span class="line">api: vendor</span><br><span class="line">    @echo &quot;生成协议文件&quot;</span><br><span class="line">    @rm -rf api &amp;&amp; mkdir api &amp;&amp; \</span><br><span class="line">    cd vendor/gitlab.mobvista.com/vta/rta_proto.git/ &amp;&amp; \</span><br><span class="line">    protoc --go_out=plugins=grpc:. *.proto &amp;&amp; \</span><br><span class="line">    cd - &amp;&amp; \</span><br><span class="line">    cp vendor/gitlab.mobvista.com/vta/rta_proto.git/* api/</span><br><span class="line"></span><br><span class="line">json: internal/rcommon/rta_common_easyjson.go</span><br><span class="line"></span><br><span class="line">internal/rcommon/rta_common_easyjson.go: internal/rcommon/rta_common.go Makefile</span><br><span class="line">    easyjson internal/rcommon/rta_common.go</span><br><span class="line"></span><br><span class="line">.PHONY: test</span><br><span class="line">test: vendor api json</span><br><span class="line">    @echo &quot;运行单元测试&quot;</span><br><span class="line">    go test -cover internal/rranker/*.go</span><br><span class="line">    go test -cover internal/rserver/*.go</span><br><span class="line">    go test -cover internal/rworker/*.go</span><br><span class="line">    go test -cover internal/rloader/*.go</span><br><span class="line">    go test -cover internal/rrecall/*.go</span><br><span class="line">    go test -cover internal/rmaster/*.go</span><br><span class="line">    go test -cover internal/rsender/*.go</span><br><span class="line"></span><br><span class="line">benchmark: benchmarkloader benchmarkall</span><br><span class="line"></span><br><span class="line">.PHONY: benchmarkloader</span><br><span class="line">benchmarkloader: vendor api json</span><br><span class="line">    @echo &quot;运行 loader 性能测试&quot;</span><br><span class="line">    go test -timeout 2h -bench BenchmarkS3Loader_Load -benchmem -cpuprofile cpu.out -memprofile mem.out -run=^$$ internal/rloader/*</span><br><span class="line">    go tool pprof -svg ./rloader.test cpu.out &gt; cpu.benchmarkloader.svg</span><br><span class="line">    go tool pprof -svg ./rloader.test mem.out &gt; mem.benchmarkloader.svg</span><br><span class="line"></span><br><span class="line">.PHONY: benchmarkserver</span><br><span class="line">benchmarkserver: vendor api json</span><br><span class="line">    @echo &quot;运行 server 性能测试&quot;</span><br><span class="line">    go test -timeout 2h -bench BenchmarkServer -benchmem -cpuprofile cpu.out -memprofile mem.out -run=^$$ internal/rserver/*</span><br><span class="line">    go tool pprof -svg ./rserver.test cpu.out &gt; cpu.benchmarkserver.svg</span><br><span class="line">    go tool pprof -svg ./rserver.test mem.out &gt; mem.benchmarkserver.svg</span><br><span class="line"></span><br><span class="line">.PHONY: benchmarkall</span><br><span class="line">benchmarkall: vendor api json</span><br><span class="line">    @echo &quot;运行 server 性能测试&quot;</span><br><span class="line">    go test -timeout 2h -bench BenchmarkAll -benchmem -cpuprofile cpu.out -memprofile mem.out -run=^$$ internal/rserver/*</span><br><span class="line">    go tool pprof -svg ./rserver.test cpu.out &gt; cpu.benchmarkall.svg    </span><br><span class="line">    go tool pprof -svg ./rserver.test mem.out &gt; mem.benchmarkall.svg</span><br><span class="line"></span><br><span class="line">.PHONY: benchmarkcache</span><br><span class="line">benchmarkcache: vendor api json</span><br><span class="line">    @echo &quot;测试 redis 集群性能&quot;</span><br><span class="line">    go test -timeout 5m -bench BenchmarkRtaCacheBatch -benchmem -cpuprofile cpu.out -memprofile mem.out -run=^$$ internal/rserver/*</span><br><span class="line"></span><br><span class="line">.PHONY: stat</span><br><span class="line">stat: cloc gocyclo</span><br><span class="line">    @echo &quot;代码行数统计&quot;</span><br><span class="line">    @ls internal/*/* scripts/* configs/* Makefile | xargs cloc --by-file</span><br><span class="line">    @echo &quot;圈复杂度统计&quot;</span><br><span class="line">    @ls internal/*/* | grep -v _test | xargs gocyclo</span><br><span class="line">    @ls internal/*/* | grep -v _test | xargs gocyclo | awk &apos;&#123;sum+=$$1&#125;END&#123;printf(&quot;总圈复杂度: %s&quot;, sum)&#125;&apos;</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">    rm -rf build</span><br><span class="line"></span><br><span class="line">.PHONY: deep_clean</span><br><span class="line">deep_clean:</span><br><span class="line">    rm -rf vendor api build third</span><br><span class="line"></span><br><span class="line">third: protoc glide golang cloc gocyclo easyjson</span><br><span class="line"></span><br><span class="line">.PHONY: protoc</span><br><span class="line">protoc: golang</span><br><span class="line">    @hash protoc 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装 protobuf 代码生成工具 protoc&quot; &amp;&amp; \</span><br><span class="line">        mkdir -p third &amp;&amp; cd third &amp;&amp; \</span><br><span class="line">        wget https://github.com/google/protobuf/releases/download/v3.2.0/protobuf-cpp-3.2.0.tar.gz &amp;&amp; \</span><br><span class="line">        tar -xzvf protobuf-cpp-3.2.0.tar.gz &amp;&amp; \</span><br><span class="line">        cd protobuf-3.2.0 &amp;&amp; \</span><br><span class="line">        ./configure --prefix=`pwd`/../protobuf &amp;&amp; \</span><br><span class="line">        make -j8 &amp;&amp; \</span><br><span class="line">        make install &amp;&amp; \</span><br><span class="line">        cd ../.. &amp;&amp; \</span><br><span class="line">        protoc --version; \</span><br><span class="line">    &#125;</span><br><span class="line">    @hash protoc-gen-go 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装 protobuf golang 插件 protoc-gen-go&quot; &amp;&amp; \</span><br><span class="line">        go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: glide</span><br><span class="line">glide: golang</span><br><span class="line">    @mkdir -p $$GOPATH/bin</span><br><span class="line">    @hash glide 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装依赖管理工具 glide&quot; &amp;&amp; \</span><br><span class="line">        curl https://glide.sh/get | sh; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: golang</span><br><span class="line">golang:</span><br><span class="line">    @hash go 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装 golang 环境 go1.10&quot; &amp;&amp; \</span><br><span class="line">        mkdir -p third &amp;&amp; cd third &amp;&amp; \</span><br><span class="line">        wget https://dl.google.com/go/go1.10.linux-amd64.tar.gz &amp;&amp; \</span><br><span class="line">        tar -xzvf go1.10.linux-amd64.tar.gz &amp;&amp; \</span><br><span class="line">        cd .. &amp;&amp; \</span><br><span class="line">        go version; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: cloc</span><br><span class="line">cloc:</span><br><span class="line">    @hash cloc 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装代码统计工具 cloc&quot; &amp;&amp; \</span><br><span class="line">        mkdir -p third &amp;&amp; cd third &amp;&amp; \</span><br><span class="line">        wget https://github.com/AlDanial/cloc/archive/v1.76.zip &amp;&amp; \</span><br><span class="line">        unzip v1.76.zip; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: gocyclo</span><br><span class="line">gocyclo: golang</span><br><span class="line">    @hash gocyclo 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装代码圈复杂度统计工具 gocyclo&quot; &amp;&amp; \</span><br><span class="line">        go get -u github.com/fzipp/gocyclo; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: easyjson</span><br><span class="line">easyjson: golang</span><br><span class="line">    @hash easyjson 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装 json 编译工具 easyjson&quot; &amp;&amp; \</span><br><span class="line">        go get -u github.com/mailru/easyjson/...; \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想比与java的编译来说 golang的编译十分简单&lt;/p&gt;
&lt;p&gt;但是。下载依赖包以及测试等工作都需要一些构建技术&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang test</title>
    <link href="http://yoursite.com/2018/10/08/golang-test/"/>
    <id>http://yoursite.com/2018/10/08/golang-test/</id>
    <published>2018-10-08T13:48:32.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在只是加上一些关于性能测试的一点拾遗。之后会添加gotests框架的使用等</p><a id="more"></a><p>testing包提供了对Go包的自动测试支持。 go test 命令会自动执行所以符合格式<br>func TestXXX(t *testing.T) 的函数。</p><p>还有一些func BenchmarkXxx(b *testing.B)形式的函数<br>这种形式的函数被称为性能测试</p><p>当带着 -bench=“.”来执行*go test命令的时候性能测试程序就会被顺序执行。</p><p>举一个简单的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package lib</span><br><span class="line"></span><br><span class="line">func Add(x int, y int) (z int) &#123;</span><br><span class="line">    z = x + y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type ForTest struct &#123;</span><br><span class="line">    num int ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this * ForTest) Loops() &#123;</span><br><span class="line">    for i:=0 ; i  &lt; 10000 ; i++ &#123;</span><br><span class="line">        this.num++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package lib</span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">type AddArray struct &#123;</span><br><span class="line">    result  int;</span><br><span class="line">    add_1   int;</span><br><span class="line">    add_2   int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func BenchmarkLoops(b *testing.B) &#123;</span><br><span class="line">    var test ForTest</span><br><span class="line">    ptr := &amp;test</span><br><span class="line">    // 必须循环 b.N 次 。 这个数字 b.N 会在运行中调整，以便最终达到合适的时间消耗。方便计算出合理的数据。 （ 免得数据全部是 0 ） </span><br><span class="line">    for i:=0 ; i&lt;b.N ; i++ &#123;</span><br><span class="line">        ptr.Loops()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 测试并发效率</span><br><span class="line">func BenchmarkLoopsParallel(b *testing.B) &#123;</span><br><span class="line">    b.RunParallel(func(pb *testing.PB) &#123;</span><br><span class="line">        var test ForTest</span><br><span class="line">        ptr := &amp;test</span><br><span class="line">        for pb.Next() &#123;</span><br><span class="line">            ptr.Loops()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t * testing.T) &#123;</span><br><span class="line">    var test_data = [3] AddArray &#123;</span><br><span class="line">        &#123; 2, 1, 1&#125;,</span><br><span class="line">        &#123; 5, 2, 3&#125;,</span><br><span class="line">        &#123; 4, 2, 2&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    for _ , v := range test_data &#123;</span><br><span class="line">        if v.result != Add(v.add_1, v.add_2) &#123;</span><br><span class="line">            t.Errorf(&quot;Add( %d , %d ) != %d \n&quot;, v.add_1 , v.add_2 , v.result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 go test -bench=”.” 后 结果 ： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 表示测试全部通过</span><br><span class="line">&gt;PASS                       </span><br><span class="line">// Benchmark 名字 - CPU            循环次数             平均每次执行时间 </span><br><span class="line">BenchmarkLoops-2                  100000             20628 ns/op     </span><br><span class="line">BenchmarkLoopsParallel-2          100000             10412 ns/op   </span><br><span class="line">//      哪个目录下执行go test         累计耗时</span><br><span class="line">ok      swap/lib                   2.279s</span><br></pre></td></tr></table></figure><p>Go testing 库 testing.T 和 testing.B 简介</p><p>testing.T</p><p>判定失败接口<br>Fail  失败继续<br>FailNow 失败终止<br>打印信息接口<br>Log   数据流 （cout　类似）<br>Logf   format (printf 类似）<br>SkipNow 跳过当前测试<br>Skiped 检测是否跳过</p><p>综合接口产生： </p><p>Error / Errorf 报告出错继续 [ Log / Logf + Fail ]<br>Fatel / Fatelf 报告出错终止 [ Log / Logf + FailNow ]<br>Skip / Skipf       报告并跳过 [ Log / Logf + SkipNow ]</p><p>testing.B</p><p>首先 ， testing.B 拥有testing.T 的全部接口。<br>SetBytes( i uint64) 统计内存消耗， 如果你需要的话。<br>SetParallelism(p int) 制定并行数目。<br>StartTimer / StopTimer / ResertTimer 操作计时器</p><p>testing.PB</p><p>Next() 接口 。 判断是否继续循环</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在只是加上一些关于性能测试的一点拾遗。之后会添加gotests框架的使用等&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang map分析</title>
    <link href="http://yoursite.com/2018/09/30/golang-map%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/30/golang-map分析/</id>
    <published>2018-09-30T08:19:55.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang cache</title>
    <link href="http://yoursite.com/2018/09/29/golang-cache/"/>
    <id>http://yoursite.com/2018/09/29/golang-cache/</id>
    <published>2018-09-29T04:11:54.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>iam项目中的一个分支中。。需要简单实现一个cache，为这个小项目写下一些思考</p><a id="more"></a><p>最简单的方式就是 map了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var authMap map[string]string = make(map[string]string)</span><br></pre></td></tr></table></figure><p>这样就可以了。把mis号当成key，具体的auth关系当成 value</p><p>但是 多个线程访问一定会导致 线程不安全的情况。再复杂一点 加上读写锁 就OK了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var authMap map[string]string = make(map[string]string)</span><br><span class="line">var authMapLock sync.Mutex</span><br></pre></td></tr></table></figure><p>之后怎么用呢，也不需要特意写出get set方法，直接加锁后往map里读写东西就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">authMapLock.Lock()</span><br><span class="line">    defer authMapLock.Unlock()</span><br><span class="line"></span><br><span class="line">    if organizationId, ok := authMap[name]; ok &#123;</span><br><span class="line">        return organizationId, nil</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>小型的一个缓存就完成了。<br>紧接着 在这里看到了一个lru的解决方案。简单易懂 就记录下来了。<br><a href="https://segmentfault.com/a/1190000014479050" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014479050</a></p><p>通常最近被访问的数据,那么它就有可能会被后续继续访问</p><p><img src="/img/chache1.png" alt="avatar"></p><p>假设缓存大小为4,而写入顺序为A B C D E D F.访问顺序分为写入以及读取两种操作,写入需要更新访问时间,并且当数据到达最大缓存时需要逐出数据,而读取只会更新访问时间,写入置换算法流程如上图所示.</p><p>当未到达缓存大小时,所有数据按写入存储,并记录写入次序.<br>写入E时缓存已经满,且E的值不存在,需要逐出最久未访问的数据A,此时缓存内容为E D C B.<br>下一个写入D, D在缓存中,直接更新D的访问次序,此时缓存内容为 D E C B<br>下一个写入F, F不在缓存中,逐出缓存中的末尾C,此时缓存内容为 F D E C</p><p>采用go,可以使用list加map实现LRU cache,具体思路为:<br>写入时,先从map中查询,如果能查询,如果能查询到值,则将该值的在List中移动到最前面.如果查询不到值,则判断当前map是否到达最大值,如果到达最大值则移除List最后面的值,同时删除map中的值,如果map容量未达最大值,则写入map,同时将值放在List最前面.</p><p>读取时,从map中查询,如果能查询到值,则直接将List中该值移动到最前面,返回查询结果.</p><p>为保证并发安全,需要引入读写锁.<br>另外,存在读取List中内容反差map的情况,因为声明一个容器对象同时保存key以及value, List中以及map中存储的都是容器对象的引用.<br>引入原子对象对命中数以及未命中数等指标进行统计</p><p>核心代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func (c *MemCache) Set(key string, value interface&#123;&#125;) &#123;</span><br><span class="line">    c.mutex.Lock()</span><br><span class="line">    defer c.mutex.Unlock()</span><br><span class="line">    if c.cache == nil &#123;</span><br><span class="line">        c.cache = make(map[interface&#123;&#125;]*list.Element)</span><br><span class="line">        c.cacheList = list.New()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否在map中,如果在map中,则将value从list中移动到前面.</span><br><span class="line">    if ele, ok := c.cache[key]; ok &#123;</span><br><span class="line">        c.cacheList.MoveToFront(ele)</span><br><span class="line">        ele.Value.(*entry).value = value</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果不再map中,将值存到List最前面</span><br><span class="line">    ele := c.cacheList.PushFront(&amp;entry&#123;key: key, value: value&#125;)</span><br><span class="line">    c.cache[key] = ele</span><br><span class="line">    //判断是否到达容量限制,到达容量限制时删除List中最后面的值.</span><br><span class="line">    if c.maxItemSize != 0 &amp;&amp; c.cacheList.Len() &gt; c.maxItemSize &#123;</span><br><span class="line">        c.RemoveOldest()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (c *MemCache) Get(key string) (interface&#123;&#125;, bool) &#123;</span><br><span class="line">    c.mutex.RLock()</span><br><span class="line">    defer c.mutex.RUnlock()</span><br><span class="line">    c.gets.Add(1)</span><br><span class="line">    //如果读取到值,移动在List中位置,并返回value</span><br><span class="line">    if ele, hit := c.cache[key]; hit &#123;</span><br><span class="line">        c.hits.Add(1)</span><br><span class="line">        c.cacheList.MoveToFront(ele)</span><br><span class="line">        return ele.Value.(*entry).value, true</span><br><span class="line">    &#125;</span><br><span class="line">    return nil, false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一章对golang的map做一些分析</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iam项目中的一个分支中。。需要简单实现一个cache，为这个小项目写下一些思考&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang 博客" scheme="http://yoursite.com/tags/golang-%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>java项目部署到linux</title>
    <link href="http://yoursite.com/2018/09/28/java%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0linux/"/>
    <id>http://yoursite.com/2018/09/28/java项目部署到linux/</id>
    <published>2018-09-28T09:05:29.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>还是比较容易的，随手记录一下</p><p>1，在maven项目中执行mvn</p><p>mvn clean install -Dmaven.test.skip=true</p><p>2，在export包中找到jar文件</p><p>3，拷贝到linux中 执行java jar +filename</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还是比较容易的，随手记录一下&lt;/p&gt;
&lt;p&gt;1，在maven项目中执行mvn&lt;/p&gt;
&lt;p&gt;mvn clean install -Dmaven.test.skip=true&lt;/p&gt;
&lt;p&gt;2，在export包中找到jar文件&lt;/p&gt;
&lt;p&gt;3，拷贝到linux中 执行jav
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>实习linux命令总结</title>
    <link href="http://yoursite.com/2018/09/28/%E5%AE%9E%E4%B9%A0linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/28/实习linux命令总结/</id>
    <published>2018-09-28T05:04:48.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在云计算部门实习了一年多了也，从之前的linux操作每一条命令都要百度，到现在的熟练操作，记录总结一下吧。</p><a id="more"></a><p>太简单的cd什么的就不做记录了，只是列举一些常用的以防之后忘掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf archive.tar</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &quot;name&quot; *</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -iname &quot;MyProgram.c&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name =</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $2,$5;&#125;&apos; employee.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F &apos;:&apos; &apos;$3=$4&apos; /etc/passwd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -w name_list.txt name_list_new.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort names.txt</span><br><span class="line"></span><br><span class="line">sort -r names.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/data/java</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">将所有图片文件拷贝到外部驱动器</span><br><span class="line">$ ls *.jpg | xargs -n1 -i cp &#123;&#125; /external-hard-drive/directory</span><br><span class="line">将系统中所有jpd文件压缩打包</span><br><span class="line"></span><br><span class="line">$ find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz</span><br><span class="line">下载文件中列出的所有url对应的页面</span><br><span class="line"></span><br><span class="line">$ cat url-list.txt | xargs wget –c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service ssh status</span><br><span class="line"></span><br><span class="line">service ssh start</span><br><span class="line"></span><br><span class="line">service ssh stop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep</span><br></pre></td></tr></table></figure><p>free<br>这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况</p><p>默认情况下free会以字节为单位输出内存的使用量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       3566408    1580220    1986188          0     203988     902960</span><br><span class="line">-/+ buffers/cache:     473272    3093136</span><br><span class="line">Swap:      4000176          0    4000176</span><br><span class="line">如果你想以其他单位输出内存的使用量，需要加一个选项，-g为GB，-m为MB，-k为KB，-b为字节</span><br><span class="line"></span><br><span class="line">$ free -g</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:             3          1          1          0          0          0</span><br><span class="line">-/+ buffers/cache:          0          2</span><br><span class="line">Swap:            3          0          3</span><br><span class="line">如果你想查看所有内存的汇总，请使用-t选项，使用这个选项会在输出中加一个汇总行</span><br><span class="line"></span><br><span class="line">ramesh@ramesh-laptop:~$ free -t</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       3566408    1592148    1974260          0     204260     912556</span><br><span class="line">-/+ buffers/cache:     475332    3091076</span><br><span class="line">Swap:      4000176          0    4000176</span><br><span class="line">Total:     7566584    1592148    5974436</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top命令会显示当前系统中占用资源最多的一些进程（默认以CPU占用率排序）如果你想改变排序方式，可以在结果列表中点击O（大写字母O）会显示所有可用于排序的列，这个时候你就可以选择你想排序的列</span><br><span class="line"></span><br><span class="line">Current Sort Field:  P  for window 1:Def</span><br><span class="line">Select sort field via field letter, type any other key to return</span><br><span class="line"></span><br><span class="line">  a: PID        = Process Id              v: nDRT       = Dirty Pages count</span><br><span class="line">  d: UID        = User Id                 y: WCHAN      = Sleeping in Function</span><br><span class="line">  e: USER       = User Name               z: Flags      = Task Flags</span><br><span class="line">  ........</span><br><span class="line">如果只想显示某个特定用户的进程，可以使用-u选项</span><br><span class="line"></span><br><span class="line">$ top -u oracle</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">显示文件系统的磁盘使用情况，默认情况下df -k 将以字节为单位输出磁盘的使用量</span><br><span class="line"></span><br><span class="line">$ df -k</span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/sda1             29530400   3233104  24797232  12% /</span><br><span class="line">/dev/sda2            120367992  50171596  64082060  44% /home</span><br><span class="line">使用-h选项可以以更符合阅读习惯的方式显示磁盘使用量</span><br><span class="line"></span><br><span class="line">$ df -h</span><br><span class="line">Filesystem                  Size   Used  Avail Capacity  iused      ifree %iused  Mounted on</span><br><span class="line">/dev/disk0s2               232Gi   84Gi  148Gi    37% 21998562   38864868   36%   /</span><br><span class="line">devfs                      187Ki  187Ki    0Bi   100%      648          0  100%   /dev</span><br><span class="line">map -hosts                   0Bi    0Bi    0Bi   100%        0          0  100%   /net</span><br><span class="line">map auto_home                0Bi    0Bi    0Bi   100%        0          0  100%   /home</span><br><span class="line">/dev/disk0s4               466Gi   45Gi  421Gi    10%   112774  440997174    0%   /Volumes/BOOTCAMP</span><br><span class="line">//app@izenesoft.cn/public  2.7Ti  1.3Ti  1.4Ti    48%        0 18446744073709551615    0%   /Volumes/public</span><br><span class="line">使用-T选项显示文件系统类型</span><br><span class="line"></span><br><span class="line">$ df -T</span><br><span class="line">Filesystem    Type   1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/sda1     ext4    29530400   3233120  24797216  12% /</span><br><span class="line">/dev/sda2     ext4   120367992  50171596  64082060  44% /home</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chmod</span><br><span class="line">chmod用于改变文件和目录的权限</span><br><span class="line"></span><br><span class="line">给指定文件的属主和属组所有权限(包括读、写、执行)</span><br><span class="line"></span><br><span class="line">$ chmod ug+rwx file.txt</span><br><span class="line">删除指定文件的属组的所有权限</span><br><span class="line"></span><br><span class="line">$ chmod g-rwx file.txt</span><br><span class="line">修改目录的权限，以及递归修改目录下面所有文件和子目录的权限</span><br><span class="line"></span><br><span class="line">$ chmod -R ug+rwx file.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chown</span><br><span class="line">chown用于改变文件属主和属组</span><br><span class="line"></span><br><span class="line">同时将某个文件的属主改为oracle，属组改为db</span><br><span class="line"></span><br><span class="line">$ chown oracle:dba dbora.sh</span><br><span class="line">使用-R选项对目录和目录下的文件进行递归修改</span><br><span class="line"></span><br><span class="line">$ chown -R oracle:dba /home/oracle</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在云计算部门实习了一年多了也，从之前的linux操作每一条命令都要百度，到现在的熟练操作，记录总结一下吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>map结构</title>
    <link href="http://yoursite.com/2018/09/28/map%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/09/28/map结构/</id>
    <published>2018-09-28T02:59:32.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>依然是在开发者头条刷到的，看看这些底层原理，感觉对自己很有帮助</p><p>尤其是Map 这样的 Key Value 在软件开发中是非常经典的结构，常用于在内存中存放数据。</p><a id="more"></a><p>从hashmap开始介绍：</p><p>HashMap 底层是基于 数组 + 链表 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同<br><img src="/img/hashmap1.jpg" alt="avatar"><br>1.7中的实现，如图<br><img src="/img/hashmap代码.jpg" alt="avatar"></p><p>这是 HashMap 中比较核心的几个成员变量；看看分别是什么意思？</p><p>初始化桶大小，因为底层是数组，所以这是数组默认的大小。<br>桶最大值。<br>默认的负载因子（0.75）<br>table 真正存放数据的数组。<br>Map 存放数量的大小。<br>桶大小，可在初始化时显式指定。<br>负载因子，可在初始化时显式指定。<br>重点解释下负载因子：</p><p>由于给定的 HashMap 的容量大小是固定的，比如默认初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><p>因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。</p><p>根据代码可以看到其实真正存放数据的是</p><p>transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</p><p>这个数组，那么它又是如何定义的呢？</p><p><img src="/img/entry.jpg" alt="avatar"></p><p>Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出：</p><p>key 就是写入时的键。<br>value 自然就是值。<br>开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。<br>hash 存放的是当前 key 的 hashcode。<br>知晓了基本结构，那来看看其中重要的写入、获取函数：</p><p>put 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前数组是否需要初始化。<br>如果 key 为空，则 put 一个空值进去。<br>根据 key 计算出 hashcode。<br>根据计算出的 hashcode 定位出所在桶。<br>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。<br>如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        hash = (null != key) ? hash(key) : 0;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当调用 addEntry 写入 Entry 时需要判断是否需要扩容。</p><p>如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。</p><p>而在 createEntry 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。</p><p>get 方法<br>再来看看 get 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。<br>判断该位置是否为链表。<br>不是链表就根据 key、key 的 hashcode 是否相等来返回值。<br>为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。<br>啥都没取到就直接返回 null 。</p><p>Base 1.8<br>不知道 1.7 的实现大家看出需要优化的点没有？</p><p>其实一个很明显的地方就是：</p><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 O(N)。</p><p>因此 1.8 中重点优化了这个查询效率。</p><p>1.8 HashMap 结构图：</p><p><img src="/img/hash1.8" alt="avatar"></p><p>先来看看几个核心的成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">/**</span><br><span class="line"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line"> * by either of the constructors with arguments.</span><br><span class="line"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="line"> */</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">/**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> */</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">/**</span><br><span class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="line"> * for keySet() and values().</span><br><span class="line"> */</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">/**</span><br><span class="line"> * The number of key-value mappings contained in this map.</span><br><span class="line"> */</span><br><span class="line">transient int size;</span><br></pre></td></tr></table></figure><p>和 1.7 大体上都差不多，还是有几个重要的区别：</p><p>TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。<br>HashEntry 修改为 Node。<br>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 key value hashcode next 等数据。</p><p>再来看看核心方法。</p><p>put 方法</p><p><img src="/img/1.8hashput" alt="avatar"></p><p>看似要比 1.7 的复杂，我们一步步拆解：</p><p>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。<br>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。<br>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e,在第 8 步的时候会统一进行赋值及返回。<br>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。<br>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。<br>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。<br>如果在遍历过程中找到 key 相同时直接退出遍历。<br>如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。<br>最后判断是否需要进行扩容。<br>get 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 方法看起来就要简单许多了。</p><p>首先将 key hash 之后取得所定位的桶。<br>如果桶为空则直接返回 null 。<br>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。<br>如果第一个不匹配，则判断它的下一个是红黑树还是链表。<br>红黑树就按照树的查找方式返回值。<br>不然就按照链表的方式遍历匹配返回值。<br>从这两个核心方法（get/put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 O(logn)。</p><p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p><figure class="highlight plain"><figcaption><span>HashMap<string, string=""> map </string,></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            map.put(UUID.randomUUID().toString(), &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是为什么呢？简单分析下。</p><p>看过上文的还记得在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p><p>如下图：</p><p><img src="/img/hashmapbingfa1.jpg" alt="avatar"><br><img src="/img/hashmapbingfa2.jpg" alt="avatar"></p><p>遍历方式<br>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + next.getKey() + &quot; value=&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + key + &quot; value=&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>强烈建议使用第一种 EntrySet 进行遍历。</p><p>第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><p>简单总结下 HashMap：无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。</p><p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 java.util.concurrent 包下，专门用于解决并发问题。</p><p>坚持看到这里的朋友算是已经把 ConcurrentHashMap 的基础已经打牢了，下面正式开始分析</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依然是在开发者头条刷到的，看看这些底层原理，感觉对自己很有帮助&lt;/p&gt;
&lt;p&gt;尤其是Map 这样的 Key Value 在软件开发中是非常经典的结构，常用于在内存中存放数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>golang中的json转换</title>
    <link href="http://yoursite.com/2018/09/26/golang%E4%B8%AD%E7%9A%84json%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/09/26/golang中的json转换/</id>
    <published>2018-09-26T10:02:13.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一个项目遇到的最多的一个问题就是使用json的时候不能确定业务方发来的数据是整形还是字符串类型</p><p>现在找到了一个比较简单的方法优雅的解决掉这个问题<br><!-- more -- >首先定义一个结构体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Host struct &#123;</span><br><span class="line">    Name string `json:&quot;name&quot;`</span><br><span class="line">    Port Port   `json:&quot;port&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>心细的你会发现，Port既不是int也不是string类型，而是Port类型，而Port类型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Type int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Int Type = iota</span><br><span class="line">    String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Port struct &#123;</span><br><span class="line">    Type   Type</span><br><span class="line">    IntVal int</span><br><span class="line">    StrVal string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Port结构体中，我们发现了Type类型， 而Type类型包括了int,string两种类型。接下来就非常重要了，我们需要实现以下这两个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json.Unmarshaller interface</span><br><span class="line">json.Marshaller interface</span><br></pre></td></tr></table></figure></p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type Port struct &#123;</span><br><span class="line">    Type   Type</span><br><span class="line">    IntVal int</span><br><span class="line">    StrVal string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现 json.Unmarshaller 接口</span><br><span class="line">func (port *Port) UnmarshalJSON(value []byte) error &#123;</span><br><span class="line">    if value[0] == &apos;&quot;&apos; &#123;</span><br><span class="line">        port.Type = String</span><br><span class="line">        return json.Unmarshal(value, &amp;port.StrVal)</span><br><span class="line">    &#125;</span><br><span class="line">    port.Type = Int</span><br><span class="line">    return json.Unmarshal(value, &amp;port.IntVal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现 json.Marshaller 接口</span><br><span class="line">func (port Port) MarshalJSON() ([]byte, error) &#123;</span><br><span class="line">    switch port.Type &#123;</span><br><span class="line">    case Int:</span><br><span class="line">        return json.Marshal(port.IntVal)</span><br><span class="line">    case String:</span><br><span class="line">        return json.Marshal(port.StrVal)</span><br><span class="line">    default:</span><br><span class="line">        return []byte&#123;&#125;, fmt.Errorf(&quot;impossible Port.Type&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的数据结构可以这样解决吧。算是一种方法。</p>--></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一个项目遇到的最多的一个问题就是使用json的时候不能确定业务方发来的数据是整形还是字符串类型&lt;/p&gt;
&lt;p&gt;现在找到了一个比较简单的方法优雅的解决掉这个问题&lt;br&gt;&lt;!-- more -- &gt;
首先定义一个结构体
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
    
      <category term="golang 博客" scheme="http://yoursite.com/tags/golang-%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>什么是dp，dp的意义何在</title>
    <link href="http://yoursite.com/2018/09/26/%E4%BB%80%E4%B9%88%E6%98%AFdp%EF%BC%8Cdp%E7%9A%84%E6%84%8F%E4%B9%89%E4%BD%95%E5%9C%A8/"/>
    <id>http://yoursite.com/2018/09/26/什么是dp，dp的意义何在/</id>
    <published>2018-09-26T08:24:45.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天逛知乎的时候看到了 一个关于动态规划的提问，遇到了两个超级棒的回答。记录在下。<br>参考知乎 作者：王勐 徐凯强Andy<br>动态规划的本质，是对问题状态的定义和状态转移方程的定义。另外在最后提供了一种解决最长递增子序列的解法。<br><a id="more"></a><br>动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p><p>如何拆分问题，才是动态规划的核心。</p><ol><li>什么是状态的定义？</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个数列，长度为N，</span><br><span class="line">求这个数列的最长上升（递增）子数列（LIS）的长度.</span><br><span class="line">以</span><br><span class="line">1 7 2 8 3 4</span><br><span class="line">为例。</span><br><span class="line">这个数列的最长递增子数列是 1 2 3 4，长度为4；</span><br><span class="line">次长的长度为3， 包括 1 7 8; 1 2 3 等.</span><br></pre></td></tr></table></figure><p>首先要定义这个问题和这个问题的子问题。</p><p>新问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所以我们来重新定义这个问题：</span><br><span class="line">给定一个数列，长度为N，</span><br><span class="line">设F_&#123;k&#125;为：以数列中第k项结尾的最长递增子序列的长度.</span><br><span class="line">求F_&#123;1&#125;..F_&#123;N&#125; 中的最大值.</span><br></pre></td></tr></table></figure></p><p>而对于F_{k}来讲，F_{1} .. F_{k-1}都是F_{k}的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第1..k-1中某项结尾的LIS。</p><p>上述的新问题F_{k}也可以叫做状态，定义中的“F_{k}为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。</p><ol start="2"><li>什么是状态转移方程？</li></ol><p>状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程。</p><p>比如，对于LIS问题，我们的第一种定义：<br>设F_{k}为：以数列中第k项结尾的最长递增子序列的长度.</p><p>设A为题中数列，状态转移方程为：<br>F_{1} = 1 （根据状态定义导出边界情况）<br>F_{k}=max(F_{i}+1 | A_{k}&gt;A_{i}, i属于 (1..k-1)) (k&gt;1)<br>用文字解释一下是：<br>以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。</p><p>这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。<br>可以看出，状态转移方程就是带有条件的递推式。</p><ol start="3"><li>动态规划迷思</li></ol><p>a. “缓存”，“重叠子问题”，“记忆化”：这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。都不是动态规划的本质，不是动态规划的核心。</p><p>b. “递归”：<br>递归是递推式求解的方法，连技巧都算不上。</p><p>c. “无后效性”，“最优子结构”：上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是”无后效性”的通俗上的数学定义，符合这种定义的状态定义，我们可以说它具有“最优子结构”的性质，在动态规划中我们要做的，就是找到这种“最优子结构”。在对状态和状态转移方程的定义过程中，满足“最优子结构”是一个隐含的条件（否则根本定义不出来）。对状态和“最优子结构”的关系的进一步解释，</p><p>举一个简单例子：</p><p>比如说我想计算第100个非波那契数，每一个非波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。</p><p>比如说我想计算第100个非波那契数，每一个非波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。</p><p>非波那契那个例子过于简单，以至于让人忽视了阶段的概念，所谓阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合。非波那契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。想象另外一个问题情景，假如把你放在一个围棋棋盘上的某一点，你每一步只能走一格，因为你可以东南西北随便走，所以你当你同样走四步可能会处于很多个不同的位置。从头开始走了几步就是第几个阶段，走了n步可能处于的位置称为一个状态，走了这n步所有可能到达的位置的集合就是这个阶段下所有可能的状态。现在问题来了，有了阶段之后，计算新状态可能会遇到各种奇葩的情况，针对不同的情况，就需要不同的算法，下面就分情况来说明一下：</p><p>假如问题有n个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。好消息是，有时候我们并不需要真的计算所有状态，比如这样一个弱智的棋盘问题：从棋盘的左上角到达右下角最短需要几步。答案很显然，用这样一个弱智的问题是为了帮助我们理解阶段和状态。某个阶段确实可以有多个状态，正如这个问题中走n步可以走到很多位置一样。但是同样n步中，有哪些位置可以让我们在第n+1步中走的最远呢？没错，正是第n步中走的最远的位置。换成一句熟悉话叫做“下一步最优是从当前最优得到的”。所以为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫贪心。如果只看最优状态之间的计算过程是不是和非波那契数列的计算很像？所以计算的方法是递推。</p><p>既然问题都是可以划分成阶段和状态的。这样一来我们一下子解决了一大类问题：一个阶段的最优可以由前一个阶段的最优得到。</p><p>如果一个阶段的最优无法用前一个阶段的最优得到呢？</p><p>什么你说只需要之前两个阶段就可以得到当前最优？那跟只用之前一个阶段并没有本质区别。最麻烦的情况在于你需要之前所有的情况才行。再来一个迷宫的例子。在计算从起点到终点的最短路线时，你不能只保存当前阶段的状态，因为题目要求你最短，所以你必须知道之前走过的所有位置。因为即便你当前再的位置不变，之前的路线不同会影响你的之后走的路线。这时你需要保存的是之前每个阶段所经历的那个状态，根据这些信息才能计算出下一个状态！每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的。哦哦，刚刚提到的之前的路线会影响到下一步的选择，这个令人不开心的情况就叫做有后效性。</p><p>刚刚的情况实在太普遍，解决方法实在太暴力，有没有哪些情况可以避免如此的暴力呢？契机就在于后效性。有一类问题，看似需要之前所有的状态，其实不用。不妨也是拿最长上升子序列的例子来说明为什么他不必需要暴力搜索，进而引出动态规划的思路。假装我们年幼无知想用搜索去寻找最长上升子序列。怎么搜索呢？需要从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚迷宫找路的影子！咦慢着，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较就行了！这是和之前迷宫问题的本质不同！这就可以纵容我们不需要记录之前所有的状态啊！既然我们的选择已经不受之前状态的组合的影响了，那时间复杂度自然也不是指数的了啊！虽然我们不在乎某序列之前都是什么元素，但我们还是需要这个序列的长度的。所以我们只需要记录以某个元素结尾的LIS长度就好！因此第i个阶段的最优解只是由前i-1个阶段的最优解得到的，然后就得到了DP方程<br>LIS(i)=max{LIS(j)+1} j&lt; i and a[j] &lt; a[i]所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！<br>所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！每个阶段只有一个状态-&gt;递推；每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做最优子结构；而不管之前这个状态是如何得到的这个性质叫做无后效性。另：其实动态规划中的最优状态的说法容易产生误导，以为只需要计算最优状态就好，LIS问题确实如此，转移时只用到了每个阶段“选”的状态。但实际上有的问题往往需要对每个阶段的所有状态都算出一个最优值，然后根据这些最优值再来找最优状态。比如背包问题就需要对前i个包（阶段）容量为j时（状态）计算出最大价值。然后在最后一个阶段中的所有状态种找到最优值。</p><p>#最长递增子序列问题：</p><p>如果存在某个数字X比某个已有的递增子序列的最后一个元素E要大，且X在E的右边，那么X就可以添加到这个递增子序列的末尾，从而使递增子序列的长度更大。</p><p>随意想一个数列。1，9，2，3，8，5，7，4</p><p>这样下来就是1，2，3，5，7<br>长度为5</p><p>我们如何找到呢。。</p><p>只考虑最后一次搜索的情况下，那么我们扫描到7 也就是要找到之前的最长子序列，1，2，3，8或者1，2，3，5，要满足两个条件，<br>1，之前的子序列要小于7，<br>2，之前的子序列都在7的左边。</p><p>也就是那些结尾元素比当前元素小且在当前元素左边的LIS</p><p>从动态规划的角度看，一个较大的父问题被分解为了两个较小的子问题，且父问题和子问题是同一种问题。既然我们已经可以递归地找到以X结尾的LIS，为了利用这一点，我们就将整个问题转化为：对于输入序列中的每个元素X，分别找出找出以X结尾的LIS，其中长度最长的，就是我们要找的最终LIS。</p><p>动态规划进一步要求问题的解决顺序，先解决较小的问题，然后用较小问题的答案来解决较大的问题，而不要使用递归的方式。看下面的代码实现。</p><p>之后看代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  int lengthOfLIS(vector&lt;int&gt; &amp;nums)</span><br><span class="line">  &#123;</span><br><span class="line">    const int size = nums.size();</span><br><span class="line">    if (size &lt; 1)</span><br><span class="line">      return 0;</span><br><span class="line">    int max_length = 1;</span><br><span class="line">    // lengthOfLISEndAtI[i]存储了：以nums[i]结尾的LIS的长度。</span><br><span class="line">    vector&lt;int&gt; lengthOfLISEndAtI(size, 1);</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      // 当前扫描到的元素是nums[i]</span><br><span class="line">      for (int j = 0; j &lt; i; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        // 找出那些在nums[i]左边且比nums[i]小的元素</span><br><span class="line">        if (nums[j] &gt;= nums[i])</span><br><span class="line">          continue;</span><br><span class="line">        // 以nums[j]结尾的LIS与nums[i]组合，是否能产生更长的LIS（以nums[i]结尾）</span><br><span class="line">        if (lengthOfLISEndAtI[i] &lt; lengthOfLISEndAtI[j] + 1)</span><br><span class="line">        &#123;</span><br><span class="line">          lengthOfLISEndAtI[i] = lengthOfLISEndAtI[j] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 以哪个元素结尾的LIS最长</span><br><span class="line">      if (max_length &lt; lengthOfLISEndAtI[i])</span><br><span class="line">      &#123;</span><br><span class="line">        max_length = lengthOfLISEndAtI[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此算法的时间复杂度是O(n^2)。用了2层嵌套循环：</p><p>外层循环用来逐个扫描输入，假设当前扫描到的元素是X<br>内层循环用来找出在X的左边（也就是已经扫描过的），且值比X小的元素E，使X能拼接到以E结尾的LIS的后面。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天逛知乎的时候看到了 一个关于动态规划的提问，遇到了两个超级棒的回答。记录在下。&lt;br&gt;参考知乎 作者：王勐 徐凯强Andy&lt;br&gt;动态规划的本质，是对问题状态的定义和状态转移方程的定义。另外在最后提供了一种解决最长递增子序列的解法。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>tcp udp http</title>
    <link href="http://yoursite.com/2018/09/26/tcp-udp-http/"/>
    <id>http://yoursite.com/2018/09/26/tcp-udp-http/</id>
    <published>2018-09-26T02:11:32.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲的是http和tcp的关系 在最后复习一下http和udp的区别以及应用</p><a id="more"></a><p>先说一下之前的误解，<br>一直以为，或者是去年之前一直以为tcp和http没什么关系，是独立的两个协议。</p><p>#http协议是基于tcp协议的<br>这样说：tcp只是用来建立连接的 而http协议是传送数据的，实际应用中就是我们设计的restful API以及传输的json数据。</p><p>首先 传输层 三次握手建立tcp连接</p><p>建立连接完成后使用http协议传输数据<br>比如我们浏览网页是这样的：<br>浏览器 发送一个http请求给server。收到请求后，响应浏览器。浏览器把这些数据渲染成为了网页，展示在用户面前。</p><p>TCP是底层通讯协议，定义的是数据传输和连接方式的规范<br>HTTP是应用层协议，定义的是传输数据的内容的规范<br>HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP</p><p>HTTP支持的是www服务<br>而TCP/IP是协议<br>它是Internet国际互联网络的基础。TCP/IP是网络中使用的基本的通信协议。<br>TCP/IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP／IP是Internet协议族，而不单单是TCP和IP。</p><p>写到这里大概就清楚了。。可是现在习惯性的翻开知乎果然又有让我惊喜的答案。用这种大白话收尾http与tcp关系吧。</p><p>作者：老司机<br>链接：<a href="https://www.zhihu.com/question/38648948/answer/241629093" target="_blank" rel="noopener">https://www.zhihu.com/question/38648948/answer/241629093</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>下个月你就要结婚了，打个电话给老王。你先打开电话本，查找“老王”的电话号码：老王 -&gt; 13987654321（DNS解析）。然后你用手机拨打了13987654321（IP）。你的手机连接到了联通的基站（路由器），联通（你自己的网关）发现这是个移动的手机号，通过移动的帮助，找到了老王的手机（MAC），老王的手机开始响铃。“嘟……”（TCP握手）-“喂？老绿啊！”“哈哈，是我啊，老王！（连接建立）下个月我结婚，你有空吗？”（开始传输数据，先说事）“噢，有啊！”-“那你记一下地址啊（再说时间地点）！北京市东长安街16号午门太和殿。”“诶，你慢点说（流量控制），我记一下。”-“北京市”（缩小了滑动窗口）“嗯，然后呢？”（ACK）“东长安街16号”“东……16号”（ACK）-“午门太和殿”“午门（ACK“午门”）什么殿？你再说一遍，我没听清！”（“太和殿”传输失败，数据包丢失）-“太和殿”（重传）“好！记下了”（传输成功）-“那回见啊！”（准备断开连接）“好嘞！”【通话已结束】（连接断开）刚才的例子实际上传递了一段信息：我下个月结婚。HTTP只是信息的载体，刚才说的“汉语”就是HTTP。你也可以用其他协议传递，比如“I’m getting married next month”，只要对方能理解协议，那就是同一个意思。电话线路相当于一个TCP连接。TCP提供了流量控制、数据重传等机制保证了数据可靠顺序传输。当然这个例子中，可靠传输是靠人来保证的。HTTP和TCP的联系，是HTTP（要结婚的消息）使用TCP（电话）提供的“传输能力”。除此之外，没了。很多答案都提到了，网络协议是一个栈，提供对等通信。这里解释下对等。老王和老绿只与电话发生交互，他们不理解声音如何转换成电信号，也不理解电磁波如何传播。他们只知道，我对着电话说汉语，对方就能听到汉语。老王和老绿就是一个对等的协议层。两部电话也是对等的协议层，它们给上面的老王和老绿提供传输语音的服务。而电话提供的服务，底层又依赖电磁波传递无线信号。最后形成了一个个服务层，完成了打电话这个事情。再举个栗子，两个老板要约时间谈生意，他们会跟自己的秘书下达指令，让秘书搞定约会这个事。双方的秘书会互相联系，约好时间地点和司机，最后搞定这个问题。老板们不会跟对方的秘书联系（除非是小老板对马老板，那他们实际上就是不对等的），因为他们不是一个层的。把上文层次的概念，放到计算机网络中，就是协议栈。协议栈的每一层，都专注于自己层的事情：HTTP专注于要传输的信息（HTTP是信息的载体，所以在协议里面会标注信息长度，信息类型等），TCP专注于传输的可靠（为了可靠传输，TCP会给自己层的包标注大小和顺序，并且有确认机制），IP负责因特网传输（IP也有自己的格式，自己查吧），再下面的层负责与局域网和硬件打交道。简单来说，网络协议栈里面，每层都解决了计算机通信流程的某一环节的问题。它们使用下层提供的能力跟对方机器的相应协议层通信，给上层提供自己的服务。最后，TCP的下层是IP。“我下个月结婚”这几个字，你也可以通过短信（UDP）或微信（其他传输协议）来发送。虽然传输层协议不一样（电话 vs 短信），底层还是依赖IP协议（发短信仍然需要知道对方的电话号码）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲的是http和tcp的关系 在最后复习一下http和udp的区别以及应用&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>redis面试</title>
    <link href="http://yoursite.com/2018/09/25/redis%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2018/09/25/redis面试/</id>
    <published>2018-09-25T12:09:23.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理的一些关于redis入门以及面试的东西</p><a id="more"></a><p>#1. 简介<br>单线程为什么这么快？</p><p>纯内存<br>非阻塞IO<br>避免线程切换和竞争消耗<br>单线程Redis注意事项</p><p>一次只运行一条命令</p><p>拒绝长（慢）命令，例如：keys、flushall、flushdb、slow lua script、mutil/exec、operate big value(collection)</p><p>Redis其实不是单线程，fysnc file descriptor进行持久化</p><p>特性</p><p>速度快<br>持久化<br>多钟数据结构<br>支持多种编程语言<br>功能丰富<br>简单<br>主从复制<br>高可用，分布式</p><p>#2. 应用场景<br>缓存系统</p><p>排行版</p><p>计数器</p><p>社交网络</p><p>消息队列系统</p><p>实时系统</p><p>#3. 数据类型</p><p>redis</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理的一些关于redis入门以及面试的东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>算法思想-排序部分</title>
    <link href="http://yoursite.com/2018/09/25/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2018/09/25/算法思想/</id>
    <published>2018-09-25T10:45:21.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>从排序说起：</p><a id="more"></a><p>1，选择排序<br><img src="/img/选择排序.gif" alt="avatar"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(int[] arr) &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        // 寻找[i, n)区间里的最小值的索引</span><br><span class="line">        int minIndex = i;</span><br><span class="line">        for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">            if(arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap( arr , i , minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>，最简单的例子 冒泡排序<br><img src="/img/冒泡排序.gif" alt="avatar"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(int[] arr) &#123;</span><br><span class="line">    for (int i = arr.length - 1; i &gt; 0; i--) &#123; // 从最后一位开始确定</span><br><span class="line">        boolean swapped = false;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                swapped = true;</span><br><span class="line">                swap(arr,j,j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!swapped)</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><ol start="2"><li>插入排序（Insertion Sort）最简单的例子：平时玩扑克牌的时候插入排序<br><img src="/img/插入排序.gif" alt="avatar"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(int[] arr) &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for (int j = i + 1; j &gt; 0; j--) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[j - 1])</span><br><span class="line">                swap(arr, j, j - 1); // 大量的交换会消耗时间</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>另一种改进的减少了数组元素的操作次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 改进版插入排序（减少了数组元素的操作次数）</span><br><span class="line">public static void better_sort(int[] arr) &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        int e = arr[i];</span><br><span class="line">        int j = i;</span><br><span class="line">        for (; j &gt; 0; j--) &#123;</span><br><span class="line">            if (e &lt; arr[j - 1])</span><br><span class="line">                arr[j] = arr[j - 1];</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>3,希尔排序（Shell Sort）（为什么可以突破n2）<br>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><img src="/img/希尔排序.gif" alt="avatar"><br>算法描述</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(int[] arr) &#123;</span><br><span class="line">    int n = arr.length;</span><br><span class="line">    for (int h = n / 2; h &gt; 0; h = h / 2) &#123;</span><br><span class="line">        // 内部是一个插入排序</span><br><span class="line">        for (int i = 0; i &lt; n; i = i + h) &#123;</span><br><span class="line">            int e = arr[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            for (; j &gt; 0; j = j - h) &#123;</span><br><span class="line">                if (e &lt; arr[j - h])</span><br><span class="line">                    arr[j] = arr[j - h];</span><br><span class="line">                else</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种方式要计算步长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void sort2(int[] arr) &#123;</span><br><span class="line">    int n = arr.length;</span><br><span class="line">    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...</span><br><span class="line">    int h = 1;</span><br><span class="line">    while (h &lt; n / 3) h = 3 * h + 1;</span><br><span class="line"></span><br><span class="line">        System.out.println(h);</span><br><span class="line">        while (h &gt;= 1) &#123;</span><br><span class="line">            // h-sort the array</span><br><span class="line">            for (int i = h; i &lt; n; i++) &#123;</span><br><span class="line">                // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序</span><br><span class="line">                int e = arr[i];</span><br><span class="line">                int j = i;</span><br><span class="line">                for (; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)</span><br><span class="line">                    arr[j] = arr[j - h];</span><br><span class="line">                arr[j] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= 3;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。</p><p>希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><p>#为了改进插入排序的这种局限性</p><ol start="4"><li>归并排序（Merge Sort）<br><img src="/img/归并排序.gif" alt="avatar"><br>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(int[] arr) &#123;</span><br><span class="line">    __MergeSort(arr, 0, arr.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void __MergeSort(int[] arr, int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r)</span><br><span class="line">        return;</span><br><span class="line">    int mid = (l + r) / 2;</span><br><span class="line">    __MergeSort(arr, l, mid);</span><br><span class="line">    __MergeSort(arr, mid + 1, r);</span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将arr[l...mid]和arr[mid+1...r]两部分进行归并</span><br><span class="line">private static void merge(int[] arr, int l, int mid, int r) &#123;</span><br><span class="line">    int[] aux = Arrays.copyOfRange(arr, l, r + 1);</span><br><span class="line"></span><br><span class="line">    // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span><br><span class="line">    int i = l, j = mid + 1;</span><br><span class="line">    for (int k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        if (i &gt; mid) &#123;  // 如果左半部分元素已经全部处理完毕</span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else if (j &gt; r) &#123;   // 如果右半部分元素已经全部处理完毕</span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else if (aux[i - l] &lt; aux[j - l]) &#123;  // 左半部分所指元素 &lt; 右半部分所指元素</span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;  // 左半部分所指元素 &gt;= 右半部分所指元素</span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>5，快速排序<br>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。<br><img src="/img/快速排序.gif" alt="avatar"><br>快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p><p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 递归使用快速排序,对arr[l...r]的范围进行排序</span><br><span class="line">public static void QuickSort(int[] arr,int l,int r)&#123;</span><br><span class="line">    if(l&gt;=r)</span><br><span class="line">        return;</span><br><span class="line">    int p = partition(arr,l,r);</span><br><span class="line">    QuickSort(arr,l,p-1);</span><br><span class="line">    QuickSort(arr,p+1,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将数组通过p分割成两部分</span><br><span class="line">// 对arr[l...r]部分进行partition操作</span><br><span class="line">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span><br><span class="line">public static int partition(int[] arr, int l, int r) &#123;</span><br><span class="line">    swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);  // 加入这一行变成随机快速排序</span><br><span class="line"></span><br><span class="line">    int v = arr[l];</span><br><span class="line">    int j = l;</span><br><span class="line">    for(int i = j +1;i&lt;=r;i++)&#123;</span><br><span class="line">        if(arr[i] &lt; v)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr,l,j);</span><br><span class="line">    //只能确定左边都比他小</span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] arr,int i,int j) &#123;</span><br><span class="line">    int temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>双路的快速排序<br><img src="/img/双路快速排序.jpg" alt="avatar"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 双路快速排序的partition</span><br><span class="line">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span><br><span class="line">private static int partition(int[] arr, int l, int r) &#123;</span><br><span class="line"></span><br><span class="line">    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span><br><span class="line">    // swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);</span><br><span class="line"></span><br><span class="line">    int v = arr[l];</span><br><span class="line"></span><br><span class="line">    // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v</span><br><span class="line">    int i = l + 1, j = r;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0</span><br><span class="line">        // 思考一下为什么?</span><br><span class="line">        while (i &lt;= r &amp;&amp; arr[i] &lt; v)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        // 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0</span><br><span class="line">        // 思考一下为什么?</span><br><span class="line">        while (j &gt;= l + 1 &amp;&amp; arr[j] &gt; v)</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)</span><br><span class="line">        // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html</span><br><span class="line">        if (i &gt; j)</span><br><span class="line">            break;</span><br><span class="line">        </span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归使用快速排序,对arr[l...r]的范围进行排序</span><br><span class="line">private static void QuickSort2Ways(int[] arr, int l, int r) &#123;</span><br><span class="line">    // 对于小规模数组, 使用插入排序</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line">    int p = partition(arr, l, r);</span><br><span class="line">    QuickSort2Ways(arr, l, p - 1);</span><br><span class="line">    QuickSort2Ways(arr, p + 1, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6，堆排序（Heap Sort）</p><ol><li>堆<br>堆的某个节点的值总是大于等于子节点的值，并且堆是一颗完全二叉树。</li></ol><p>堆可以用数组来表示，因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p><ol start="2"><li>上浮和下沉<br>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮（ShiftUp）。</li></ol><p><img src="/img/heap1.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void shiftUp(int k)&#123;</span><br><span class="line">    while( k &gt; 1 &amp;&amp; data[k/2] &lt; data[k]))&#123;</span><br><span class="line">        swap(k, k/2);</span><br><span class="line">        k /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉（Shift Down）。一个节点如果有两个子节点，应当与两个子节点中最大那么节点进行交换。<br><img src="/img/heap2.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void shiftDown(int k)&#123;</span><br><span class="line">    while( 2*k &lt;= count )&#123; // 当前结点有左孩子</span><br><span class="line">        int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置</span><br><span class="line">        if( j+1 &lt;= count &amp;&amp; data[j+1] &gt; data[j] )</span><br><span class="line">            j ++;</span><br><span class="line">        // data[j] 是 data[2*k]和data[2*k+1]中的最大值</span><br><span class="line"></span><br><span class="line">        if( data[k] &gt;= data[j] ) </span><br><span class="line">            break;</span><br><span class="line">        swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.插入元素<br>将新元素放到数组末尾，然后上浮到合适的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 向最大堆中插入一个新的元素 item</span><br><span class="line">public void insert(Item item)&#123;</span><br><span class="line">    assert count + 1 &lt;= capacity;</span><br><span class="line">    data[count+1] = item;</span><br><span class="line">    count ++;</span><br><span class="line">    shiftUp(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>删除最大元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span><br><span class="line">public Item extractMax()&#123;</span><br><span class="line">    assert count &gt; 0;</span><br><span class="line">    Item ret = data[1];</span><br><span class="line">    </span><br><span class="line">    swap( 1 , count );</span><br><span class="line">    count --;</span><br><span class="line">    shiftDown(1);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>堆排序</p></li></ol><p>由于堆可以很容易得到最大的元素并删除它，不断地进行这种操作可以得到一个递减序列。如果把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列。因此很容易使用堆来进行排序。并且堆排序是原地排序，不占用额外空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">    // 对整个arr数组使用HeapSort1排序</span><br><span class="line">    // HeapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span><br><span class="line">    // 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span><br><span class="line">    // 整个堆排序的整体时间复杂度为O(nlogn)</span><br><span class="line">    public static void sort1(Comparable[] arr)&#123;</span><br><span class="line"></span><br><span class="line">        int n = arr.length;</span><br><span class="line">        MaxHeap&lt;Comparable&gt; maxHeap = new MaxHeap&lt;Comparable&gt;(n);</span><br><span class="line">        for( int i = 0 ; i &lt; n ; i ++ )</span><br><span class="line">            maxHeap.insert(arr[i]);</span><br><span class="line"></span><br><span class="line">        for( int i = n-1 ; i &gt;= 0 ; i -- )</span><br><span class="line">            arr[i] = maxHeap.extractMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 只通过shiftDown操作进行排序</span><br><span class="line">    public static void sort2(Comparable[] arr)&#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line"></span><br><span class="line">        // 注意，此时我们的堆是从0开始索引的</span><br><span class="line">        // 从(最后一个元素的索引-1)/2开始</span><br><span class="line">        // 最后一个元素的索引 = n-1</span><br><span class="line">        for( int i = (n-1-1)/2 ; i &gt;= 0 ; i -- )</span><br><span class="line">            shiftDown2(arr, n, i);</span><br><span class="line"></span><br><span class="line">        for( int i = n-1; i &gt; 0 ; i-- )&#123; // 这个的目的是让序列从小到大排序</span><br><span class="line">            swap( arr, 0, i);</span><br><span class="line">            shiftDown2(arr, i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 交换堆中索引为i和j的两个元素</span><br><span class="line">    private static void swap(Object[] arr, int i, int j)&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 原始的shiftDown过程</span><br><span class="line">    private static void shiftDown(Comparable[] arr, int n, int k)&#123;</span><br><span class="line">        while( 2*k+1 &lt; n )&#123;</span><br><span class="line">            int j = 2*k+1;</span><br><span class="line">            if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )</span><br><span class="line">                j += 1;</span><br><span class="line"></span><br><span class="line">            if( arr[k].compareTo(arr[j]) &gt;= 0 )break;</span><br><span class="line"></span><br><span class="line">            swap( arr, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 优化的shiftDown过程, 使用赋值的方式取代不断的swap,</span><br><span class="line">    // 该优化思想和我们之前对插入排序进行优化的思路是一致的</span><br><span class="line">    private static void shiftDown2(Comparable[] arr, int n, int k)&#123;</span><br><span class="line"></span><br><span class="line">        Comparable e = arr[k];</span><br><span class="line">        while( 2*k+1 &lt; n )&#123;</span><br><span class="line">            int j = 2*k+1;</span><br><span class="line">            if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )</span><br><span class="line">                j += 1;</span><br><span class="line"></span><br><span class="line">            if( e.compareTo(arr[j]) &gt;= 0 )</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            arr[k] = arr[j];</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[k] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试 HeapSort</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] arr = &#123;10, 91, 8, 7, 6, 5, 4, 3, 2, 1&#125;;</span><br><span class="line">        HeapSort.sort2(arr);</span><br><span class="line">        PrintHelper.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从排序说起：&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
