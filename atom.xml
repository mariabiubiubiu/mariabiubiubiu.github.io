<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mario</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-15T03:03:00.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mario MU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang json 遇到的坑</title>
    <link href="http://yoursite.com/2019/02/15/golang-json-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2019/02/15/golang-json-遇到的坑/</id>
    <published>2019-02-15T02:58:19.000Z</published>
    <updated>2019-02-15T03:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>遇到了一个坑 使用golang bindjson的时候 无论如何也获取不到数据<br><a id="more"></a></p><p>后来发现是struct内的大小写问题</p><p>但是好奇 大小写只是控制public private 的啊，为什么在同一个包访问会导致我访问不了呢？</p><p>最后发现是涉及到反射的后 不能访问。做了一个简单测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Point struct &#123;</span><br><span class="line">X int</span><br><span class="line">Y string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">po := Point&#123;3, &quot;ddd&quot;&#125;</span><br><span class="line">s := reflect.ValueOf(&amp;po).Elem()</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">f := s.Field(i)</span><br><span class="line">fmt.Printf(&quot; %s %v \n&quot;, f.Type(), f.Interface())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">int 3 </span><br><span class="line">string ddd</span><br></pre></td></tr></table></figure><p>当把xy改为小写后 则不能访问，猜测这也就是不能访问的原因的吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到了一个坑 使用golang bindjson的时候 无论如何也获取不到数据&lt;br&gt;
    
    </summary>
    
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>微服务中的api网关</title>
    <link href="http://yoursite.com/2018/10/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84api%E7%BD%91%E5%85%B3/"/>
    <id>http://yoursite.com/2018/10/08/微服务中的api网关/</id>
    <published>2018-10-08T15:04:05.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天聊天的时候觉得之前做的iam项目有点像微服务中的api网关，发现自己真的对自己做的东西乱乱的 有好多东西没有弄明白，趁着这次 把aip网关记录一下吧。</p><a id="more"></a><p>微服务就是就是将一个大的服务分解成各个不同的小服务。每一个小服务都可以拥有自己的服务器，数据库等，通常以restful APi的形式提供给服务方。</p><p>设想这么一种情况吧。。<br>前端页面需要展示数据，这些数据包含了两部分，两部分分别需要请求不同的微服务。这样如何解决呢？：</p><p>首先要注意几个问题。：<br>服务可能使用了多种协议，因为不同的协议有不同的应场景用，比如可能同时使用 HTTP, AMQP, gRPC 等。<br>服务的划分可能随着时间而变化。<br>服务的实例或者Host+端口可能会动态的变化。</p><p>相应的 服务调用方也有这种问题：</p><p>粗粒度的API，而微服务通常提供的细粒度的API，对于UI来说如果要调用细粒度的api可能需要调用很多次，这是个不小的问题。<br>不同的客户端设备可能需要不同的数据。Web,H5,APP<br>不同设备的网络性能，对于多个api来说，这个访问需要转移的服务端会快得多</p><p>这样 就引出了我们的api网关了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。</span><br><span class="line">API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。</span><br></pre></td></tr></table></figure><p>分别介绍这两种</p><p>单节点 API 网关<br><img src="/img/单节点网关.png" alt="avatar"></p><p>Backends for frontends 网关<br><img src="/img/Backends网关.png" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天聊天的时候觉得之前做的iam项目有点像微服务中的api网关，发现自己真的对自己做的东西乱乱的 有好多东西没有弄明白，趁着这次 把aip网关记录一下吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>golang makefile</title>
    <link href="http://yoursite.com/2018/10/08/golang-makefile/"/>
    <id>http://yoursite.com/2018/10/08/golang-makefile/</id>
    <published>2018-10-08T14:54:29.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>想比与java的编译来说 golang的编译十分简单</p><p>但是。下载依赖包以及测试等工作都需要一些构建技术</p><a id="more"></a><p>我们当然可以使用脚本来写到shell里来执行<br>但是。可读性较差</p><p>我们可以在实际项目中使用makefile来构建代码</p><p>make build: 编译<br>make vendor: 下载依赖<br>make api: 生成协议代码<br>make json: easyjson 代码生成<br>make test: 运行单元测试<br>make benchmark: 运行性能测试<br>make stat: 代码复杂度统计，代码行数统计<br>make clean: 清理 build 目录<br>make deep_clean: 清理所有代码以外的其他文件<br>make third: 下载所有依赖的第三方工具<br>make protoc: 下载 protobuf 工具<br>make glide: 下载 glide 依赖管理工具<br>make golang: 下载 golang 环境<br>make cloc: 下载 cloc 统计工具<br>make gocyclo: 下载 gocyclo 圈复杂度计算工具<br>make easyjson: 下载 easyjson 工具</p><p>举两个实际开发例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">export PATH:=$&#123;PATH&#125;:$&#123;GOPATH&#125;/bin:$(shell pwd)/third/go/bin:$(shell pwd)/third/protobuf/bin:$(shell pwd)/third/cloc-1.76</span><br><span class="line"></span><br><span class="line">.PHONY: all</span><br><span class="line">all: third vendor api json build test stat</span><br><span class="line"></span><br><span class="line">build: cmd/rta_server/*.go internal/*/*.go scripts/version.sh Makefile vendor api json</span><br><span class="line">    @echo &quot;编译&quot;</span><br><span class="line">    @rm -rf build/ &amp;&amp; mkdir -p build/bin/ &amp;&amp; \</span><br><span class="line">    go build -ldflags &quot;-X &apos;main.AppVersion=`sh scripts/version.sh`&apos;&quot; cmd/rta_server/main.go &amp;&amp; \</span><br><span class="line">    mv main build/bin/rta_server &amp;&amp; \</span><br><span class="line">    cp -r configs build/configs/</span><br><span class="line"></span><br><span class="line">vendor: glide.lock glide.yaml</span><br><span class="line">    @echo &quot;下载 golang 依赖&quot;</span><br><span class="line">    glide install</span><br><span class="line"></span><br><span class="line">api: vendor</span><br><span class="line">    @echo &quot;生成协议文件&quot;</span><br><span class="line">    @rm -rf api &amp;&amp; mkdir api &amp;&amp; \</span><br><span class="line">    cd vendor/gitlab.mobvista.com/vta/rta_proto.git/ &amp;&amp; \</span><br><span class="line">    protoc --go_out=plugins=grpc:. *.proto &amp;&amp; \</span><br><span class="line">    cd - &amp;&amp; \</span><br><span class="line">    cp vendor/gitlab.mobvista.com/vta/rta_proto.git/* api/</span><br><span class="line"></span><br><span class="line">json: internal/rcommon/rta_common_easyjson.go</span><br><span class="line"></span><br><span class="line">internal/rcommon/rta_common_easyjson.go: internal/rcommon/rta_common.go Makefile</span><br><span class="line">    easyjson internal/rcommon/rta_common.go</span><br><span class="line"></span><br><span class="line">.PHONY: test</span><br><span class="line">test: vendor api json</span><br><span class="line">    @echo &quot;运行单元测试&quot;</span><br><span class="line">    go test -cover internal/rranker/*.go</span><br><span class="line">    go test -cover internal/rserver/*.go</span><br><span class="line">    go test -cover internal/rworker/*.go</span><br><span class="line">    go test -cover internal/rloader/*.go</span><br><span class="line">    go test -cover internal/rrecall/*.go</span><br><span class="line">    go test -cover internal/rmaster/*.go</span><br><span class="line">    go test -cover internal/rsender/*.go</span><br><span class="line"></span><br><span class="line">benchmark: benchmarkloader benchmarkall</span><br><span class="line"></span><br><span class="line">.PHONY: benchmarkloader</span><br><span class="line">benchmarkloader: vendor api json</span><br><span class="line">    @echo &quot;运行 loader 性能测试&quot;</span><br><span class="line">    go test -timeout 2h -bench BenchmarkS3Loader_Load -benchmem -cpuprofile cpu.out -memprofile mem.out -run=^$$ internal/rloader/*</span><br><span class="line">    go tool pprof -svg ./rloader.test cpu.out &gt; cpu.benchmarkloader.svg</span><br><span class="line">    go tool pprof -svg ./rloader.test mem.out &gt; mem.benchmarkloader.svg</span><br><span class="line"></span><br><span class="line">.PHONY: benchmarkserver</span><br><span class="line">benchmarkserver: vendor api json</span><br><span class="line">    @echo &quot;运行 server 性能测试&quot;</span><br><span class="line">    go test -timeout 2h -bench BenchmarkServer -benchmem -cpuprofile cpu.out -memprofile mem.out -run=^$$ internal/rserver/*</span><br><span class="line">    go tool pprof -svg ./rserver.test cpu.out &gt; cpu.benchmarkserver.svg</span><br><span class="line">    go tool pprof -svg ./rserver.test mem.out &gt; mem.benchmarkserver.svg</span><br><span class="line"></span><br><span class="line">.PHONY: benchmarkall</span><br><span class="line">benchmarkall: vendor api json</span><br><span class="line">    @echo &quot;运行 server 性能测试&quot;</span><br><span class="line">    go test -timeout 2h -bench BenchmarkAll -benchmem -cpuprofile cpu.out -memprofile mem.out -run=^$$ internal/rserver/*</span><br><span class="line">    go tool pprof -svg ./rserver.test cpu.out &gt; cpu.benchmarkall.svg    </span><br><span class="line">    go tool pprof -svg ./rserver.test mem.out &gt; mem.benchmarkall.svg</span><br><span class="line"></span><br><span class="line">.PHONY: benchmarkcache</span><br><span class="line">benchmarkcache: vendor api json</span><br><span class="line">    @echo &quot;测试 redis 集群性能&quot;</span><br><span class="line">    go test -timeout 5m -bench BenchmarkRtaCacheBatch -benchmem -cpuprofile cpu.out -memprofile mem.out -run=^$$ internal/rserver/*</span><br><span class="line"></span><br><span class="line">.PHONY: stat</span><br><span class="line">stat: cloc gocyclo</span><br><span class="line">    @echo &quot;代码行数统计&quot;</span><br><span class="line">    @ls internal/*/* scripts/* configs/* Makefile | xargs cloc --by-file</span><br><span class="line">    @echo &quot;圈复杂度统计&quot;</span><br><span class="line">    @ls internal/*/* | grep -v _test | xargs gocyclo</span><br><span class="line">    @ls internal/*/* | grep -v _test | xargs gocyclo | awk &apos;&#123;sum+=$$1&#125;END&#123;printf(&quot;总圈复杂度: %s&quot;, sum)&#125;&apos;</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">    rm -rf build</span><br><span class="line"></span><br><span class="line">.PHONY: deep_clean</span><br><span class="line">deep_clean:</span><br><span class="line">    rm -rf vendor api build third</span><br><span class="line"></span><br><span class="line">third: protoc glide golang cloc gocyclo easyjson</span><br><span class="line"></span><br><span class="line">.PHONY: protoc</span><br><span class="line">protoc: golang</span><br><span class="line">    @hash protoc 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装 protobuf 代码生成工具 protoc&quot; &amp;&amp; \</span><br><span class="line">        mkdir -p third &amp;&amp; cd third &amp;&amp; \</span><br><span class="line">        wget https://github.com/google/protobuf/releases/download/v3.2.0/protobuf-cpp-3.2.0.tar.gz &amp;&amp; \</span><br><span class="line">        tar -xzvf protobuf-cpp-3.2.0.tar.gz &amp;&amp; \</span><br><span class="line">        cd protobuf-3.2.0 &amp;&amp; \</span><br><span class="line">        ./configure --prefix=`pwd`/../protobuf &amp;&amp; \</span><br><span class="line">        make -j8 &amp;&amp; \</span><br><span class="line">        make install &amp;&amp; \</span><br><span class="line">        cd ../.. &amp;&amp; \</span><br><span class="line">        protoc --version; \</span><br><span class="line">    &#125;</span><br><span class="line">    @hash protoc-gen-go 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装 protobuf golang 插件 protoc-gen-go&quot; &amp;&amp; \</span><br><span class="line">        go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: glide</span><br><span class="line">glide: golang</span><br><span class="line">    @mkdir -p $$GOPATH/bin</span><br><span class="line">    @hash glide 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装依赖管理工具 glide&quot; &amp;&amp; \</span><br><span class="line">        curl https://glide.sh/get | sh; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: golang</span><br><span class="line">golang:</span><br><span class="line">    @hash go 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装 golang 环境 go1.10&quot; &amp;&amp; \</span><br><span class="line">        mkdir -p third &amp;&amp; cd third &amp;&amp; \</span><br><span class="line">        wget https://dl.google.com/go/go1.10.linux-amd64.tar.gz &amp;&amp; \</span><br><span class="line">        tar -xzvf go1.10.linux-amd64.tar.gz &amp;&amp; \</span><br><span class="line">        cd .. &amp;&amp; \</span><br><span class="line">        go version; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: cloc</span><br><span class="line">cloc:</span><br><span class="line">    @hash cloc 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装代码统计工具 cloc&quot; &amp;&amp; \</span><br><span class="line">        mkdir -p third &amp;&amp; cd third &amp;&amp; \</span><br><span class="line">        wget https://github.com/AlDanial/cloc/archive/v1.76.zip &amp;&amp; \</span><br><span class="line">        unzip v1.76.zip; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: gocyclo</span><br><span class="line">gocyclo: golang</span><br><span class="line">    @hash gocyclo 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装代码圈复杂度统计工具 gocyclo&quot; &amp;&amp; \</span><br><span class="line">        go get -u github.com/fzipp/gocyclo; \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.PHONY: easyjson</span><br><span class="line">easyjson: golang</span><br><span class="line">    @hash easyjson 2&gt;/dev/null || &#123; \</span><br><span class="line">        echo &quot;安装 json 编译工具 easyjson&quot; &amp;&amp; \</span><br><span class="line">        go get -u github.com/mailru/easyjson/...; \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想比与java的编译来说 golang的编译十分简单&lt;/p&gt;
&lt;p&gt;但是。下载依赖包以及测试等工作都需要一些构建技术&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang test</title>
    <link href="http://yoursite.com/2018/10/08/golang-test/"/>
    <id>http://yoursite.com/2018/10/08/golang-test/</id>
    <published>2018-10-08T13:48:32.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在只是加上一些关于性能测试的一点拾遗。之后会添加gotests框架的使用等</p><a id="more"></a><p>testing包提供了对Go包的自动测试支持。 go test 命令会自动执行所以符合格式<br>func TestXXX(t *testing.T) 的函数。</p><p>还有一些func BenchmarkXxx(b *testing.B)形式的函数<br>这种形式的函数被称为性能测试</p><p>当带着 -bench=“.”来执行*go test命令的时候性能测试程序就会被顺序执行。</p><p>举一个简单的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package lib</span><br><span class="line"></span><br><span class="line">func Add(x int, y int) (z int) &#123;</span><br><span class="line">    z = x + y</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type ForTest struct &#123;</span><br><span class="line">    num int ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this * ForTest) Loops() &#123;</span><br><span class="line">    for i:=0 ; i  &lt; 10000 ; i++ &#123;</span><br><span class="line">        this.num++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package lib</span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">type AddArray struct &#123;</span><br><span class="line">    result  int;</span><br><span class="line">    add_1   int;</span><br><span class="line">    add_2   int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func BenchmarkLoops(b *testing.B) &#123;</span><br><span class="line">    var test ForTest</span><br><span class="line">    ptr := &amp;test</span><br><span class="line">    // 必须循环 b.N 次 。 这个数字 b.N 会在运行中调整，以便最终达到合适的时间消耗。方便计算出合理的数据。 （ 免得数据全部是 0 ） </span><br><span class="line">    for i:=0 ; i&lt;b.N ; i++ &#123;</span><br><span class="line">        ptr.Loops()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 测试并发效率</span><br><span class="line">func BenchmarkLoopsParallel(b *testing.B) &#123;</span><br><span class="line">    b.RunParallel(func(pb *testing.PB) &#123;</span><br><span class="line">        var test ForTest</span><br><span class="line">        ptr := &amp;test</span><br><span class="line">        for pb.Next() &#123;</span><br><span class="line">            ptr.Loops()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t * testing.T) &#123;</span><br><span class="line">    var test_data = [3] AddArray &#123;</span><br><span class="line">        &#123; 2, 1, 1&#125;,</span><br><span class="line">        &#123; 5, 2, 3&#125;,</span><br><span class="line">        &#123; 4, 2, 2&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    for _ , v := range test_data &#123;</span><br><span class="line">        if v.result != Add(v.add_1, v.add_2) &#123;</span><br><span class="line">            t.Errorf(&quot;Add( %d , %d ) != %d \n&quot;, v.add_1 , v.add_2 , v.result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 go test -bench=”.” 后 结果 ： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 表示测试全部通过</span><br><span class="line">&gt;PASS                       </span><br><span class="line">// Benchmark 名字 - CPU            循环次数             平均每次执行时间 </span><br><span class="line">BenchmarkLoops-2                  100000             20628 ns/op     </span><br><span class="line">BenchmarkLoopsParallel-2          100000             10412 ns/op   </span><br><span class="line">//      哪个目录下执行go test         累计耗时</span><br><span class="line">ok      swap/lib                   2.279s</span><br></pre></td></tr></table></figure><p>Go testing 库 testing.T 和 testing.B 简介</p><p>testing.T</p><p>判定失败接口<br>Fail  失败继续<br>FailNow 失败终止<br>打印信息接口<br>Log   数据流 （cout　类似）<br>Logf   format (printf 类似）<br>SkipNow 跳过当前测试<br>Skiped 检测是否跳过</p><p>综合接口产生： </p><p>Error / Errorf 报告出错继续 [ Log / Logf + Fail ]<br>Fatel / Fatelf 报告出错终止 [ Log / Logf + FailNow ]<br>Skip / Skipf       报告并跳过 [ Log / Logf + SkipNow ]</p><p>testing.B</p><p>首先 ， testing.B 拥有testing.T 的全部接口。<br>SetBytes( i uint64) 统计内存消耗， 如果你需要的话。<br>SetParallelism(p int) 制定并行数目。<br>StartTimer / StopTimer / ResertTimer 操作计时器</p><p>testing.PB</p><p>Next() 接口 。 判断是否继续循环</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在只是加上一些关于性能测试的一点拾遗。之后会添加gotests框架的使用等&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang map分析</title>
    <link href="http://yoursite.com/2018/09/30/golang-map%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/30/golang-map分析/</id>
    <published>2018-09-30T08:19:55.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang cache</title>
    <link href="http://yoursite.com/2018/09/29/golang-cache/"/>
    <id>http://yoursite.com/2018/09/29/golang-cache/</id>
    <published>2018-09-29T04:11:54.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>iam项目中的一个分支中。。需要简单实现一个cache，为这个小项目写下一些思考</p><a id="more"></a><p>最简单的方式就是 map了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var authMap map[string]string = make(map[string]string)</span><br></pre></td></tr></table></figure><p>这样就可以了。把mis号当成key，具体的auth关系当成 value</p><p>但是 多个线程访问一定会导致 线程不安全的情况。再复杂一点 加上读写锁 就OK了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var authMap map[string]string = make(map[string]string)</span><br><span class="line">var authMapLock sync.Mutex</span><br></pre></td></tr></table></figure><p>之后怎么用呢，也不需要特意写出get set方法，直接加锁后往map里读写东西就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">authMapLock.Lock()</span><br><span class="line">    defer authMapLock.Unlock()</span><br><span class="line"></span><br><span class="line">    if organizationId, ok := authMap[name]; ok &#123;</span><br><span class="line">        return organizationId, nil</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>小型的一个缓存就完成了。<br>紧接着 在这里看到了一个lru的解决方案。简单易懂 就记录下来了。<br><a href="https://segmentfault.com/a/1190000014479050" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014479050</a></p><p>通常最近被访问的数据,那么它就有可能会被后续继续访问</p><p><img src="/img/chache1.png" alt="avatar"></p><p>假设缓存大小为4,而写入顺序为A B C D E D F.访问顺序分为写入以及读取两种操作,写入需要更新访问时间,并且当数据到达最大缓存时需要逐出数据,而读取只会更新访问时间,写入置换算法流程如上图所示.</p><p>当未到达缓存大小时,所有数据按写入存储,并记录写入次序.<br>写入E时缓存已经满,且E的值不存在,需要逐出最久未访问的数据A,此时缓存内容为E D C B.<br>下一个写入D, D在缓存中,直接更新D的访问次序,此时缓存内容为 D E C B<br>下一个写入F, F不在缓存中,逐出缓存中的末尾C,此时缓存内容为 F D E C</p><p>采用go,可以使用list加map实现LRU cache,具体思路为:<br>写入时,先从map中查询,如果能查询,如果能查询到值,则将该值的在List中移动到最前面.如果查询不到值,则判断当前map是否到达最大值,如果到达最大值则移除List最后面的值,同时删除map中的值,如果map容量未达最大值,则写入map,同时将值放在List最前面.</p><p>读取时,从map中查询,如果能查询到值,则直接将List中该值移动到最前面,返回查询结果.</p><p>为保证并发安全,需要引入读写锁.<br>另外,存在读取List中内容反差map的情况,因为声明一个容器对象同时保存key以及value, List中以及map中存储的都是容器对象的引用.<br>引入原子对象对命中数以及未命中数等指标进行统计</p><p>核心代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func (c *MemCache) Set(key string, value interface&#123;&#125;) &#123;</span><br><span class="line">    c.mutex.Lock()</span><br><span class="line">    defer c.mutex.Unlock()</span><br><span class="line">    if c.cache == nil &#123;</span><br><span class="line">        c.cache = make(map[interface&#123;&#125;]*list.Element)</span><br><span class="line">        c.cacheList = list.New()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否在map中,如果在map中,则将value从list中移动到前面.</span><br><span class="line">    if ele, ok := c.cache[key]; ok &#123;</span><br><span class="line">        c.cacheList.MoveToFront(ele)</span><br><span class="line">        ele.Value.(*entry).value = value</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果不再map中,将值存到List最前面</span><br><span class="line">    ele := c.cacheList.PushFront(&amp;entry&#123;key: key, value: value&#125;)</span><br><span class="line">    c.cache[key] = ele</span><br><span class="line">    //判断是否到达容量限制,到达容量限制时删除List中最后面的值.</span><br><span class="line">    if c.maxItemSize != 0 &amp;&amp; c.cacheList.Len() &gt; c.maxItemSize &#123;</span><br><span class="line">        c.RemoveOldest()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (c *MemCache) Get(key string) (interface&#123;&#125;, bool) &#123;</span><br><span class="line">    c.mutex.RLock()</span><br><span class="line">    defer c.mutex.RUnlock()</span><br><span class="line">    c.gets.Add(1)</span><br><span class="line">    //如果读取到值,移动在List中位置,并返回value</span><br><span class="line">    if ele, hit := c.cache[key]; hit &#123;</span><br><span class="line">        c.hits.Add(1)</span><br><span class="line">        c.cacheList.MoveToFront(ele)</span><br><span class="line">        return ele.Value.(*entry).value, true</span><br><span class="line">    &#125;</span><br><span class="line">    return nil, false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一章对golang的map做一些分析</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iam项目中的一个分支中。。需要简单实现一个cache，为这个小项目写下一些思考&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang 博客" scheme="http://yoursite.com/tags/golang-%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>java项目部署到linux</title>
    <link href="http://yoursite.com/2018/09/28/java%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0linux/"/>
    <id>http://yoursite.com/2018/09/28/java项目部署到linux/</id>
    <published>2018-09-28T09:05:29.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>还是比较容易的，随手记录一下</p><p>1，在maven项目中执行mvn</p><p>mvn clean install -Dmaven.test.skip=true</p><p>2，在export包中找到jar文件</p><p>3，拷贝到linux中 执行java jar +filename</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还是比较容易的，随手记录一下&lt;/p&gt;
&lt;p&gt;1，在maven项目中执行mvn&lt;/p&gt;
&lt;p&gt;mvn clean install -Dmaven.test.skip=true&lt;/p&gt;
&lt;p&gt;2，在export包中找到jar文件&lt;/p&gt;
&lt;p&gt;3，拷贝到linux中 执行jav
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>实习linux命令总结</title>
    <link href="http://yoursite.com/2018/09/28/%E5%AE%9E%E4%B9%A0linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/28/实习linux命令总结/</id>
    <published>2018-09-28T05:04:48.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在云计算部门实习了一年多了也，从之前的linux操作每一条命令都要百度，到现在的熟练操作，记录总结一下吧。</p><a id="more"></a><p>太简单的cd什么的就不做记录了，只是列举一些常用的以防之后忘掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf archive.tar</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &quot;name&quot; *</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -iname &quot;MyProgram.c&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name =</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print $2,$5;&#125;&apos; employee.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F &apos;:&apos; &apos;$3=$4&apos; /etc/passwd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -w name_list.txt name_list_new.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort names.txt</span><br><span class="line"></span><br><span class="line">sort -r names.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/data/java</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">将所有图片文件拷贝到外部驱动器</span><br><span class="line">$ ls *.jpg | xargs -n1 -i cp &#123;&#125; /external-hard-drive/directory</span><br><span class="line">将系统中所有jpd文件压缩打包</span><br><span class="line"></span><br><span class="line">$ find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz</span><br><span class="line">下载文件中列出的所有url对应的页面</span><br><span class="line"></span><br><span class="line">$ cat url-list.txt | xargs wget –c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service ssh status</span><br><span class="line"></span><br><span class="line">service ssh start</span><br><span class="line"></span><br><span class="line">service ssh stop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep</span><br></pre></td></tr></table></figure><p>free<br>这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况</p><p>默认情况下free会以字节为单位输出内存的使用量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       3566408    1580220    1986188          0     203988     902960</span><br><span class="line">-/+ buffers/cache:     473272    3093136</span><br><span class="line">Swap:      4000176          0    4000176</span><br><span class="line">如果你想以其他单位输出内存的使用量，需要加一个选项，-g为GB，-m为MB，-k为KB，-b为字节</span><br><span class="line"></span><br><span class="line">$ free -g</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:             3          1          1          0          0          0</span><br><span class="line">-/+ buffers/cache:          0          2</span><br><span class="line">Swap:            3          0          3</span><br><span class="line">如果你想查看所有内存的汇总，请使用-t选项，使用这个选项会在输出中加一个汇总行</span><br><span class="line"></span><br><span class="line">ramesh@ramesh-laptop:~$ free -t</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       3566408    1592148    1974260          0     204260     912556</span><br><span class="line">-/+ buffers/cache:     475332    3091076</span><br><span class="line">Swap:      4000176          0    4000176</span><br><span class="line">Total:     7566584    1592148    5974436</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top命令会显示当前系统中占用资源最多的一些进程（默认以CPU占用率排序）如果你想改变排序方式，可以在结果列表中点击O（大写字母O）会显示所有可用于排序的列，这个时候你就可以选择你想排序的列</span><br><span class="line"></span><br><span class="line">Current Sort Field:  P  for window 1:Def</span><br><span class="line">Select sort field via field letter, type any other key to return</span><br><span class="line"></span><br><span class="line">  a: PID        = Process Id              v: nDRT       = Dirty Pages count</span><br><span class="line">  d: UID        = User Id                 y: WCHAN      = Sleeping in Function</span><br><span class="line">  e: USER       = User Name               z: Flags      = Task Flags</span><br><span class="line">  ........</span><br><span class="line">如果只想显示某个特定用户的进程，可以使用-u选项</span><br><span class="line"></span><br><span class="line">$ top -u oracle</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">显示文件系统的磁盘使用情况，默认情况下df -k 将以字节为单位输出磁盘的使用量</span><br><span class="line"></span><br><span class="line">$ df -k</span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/sda1             29530400   3233104  24797232  12% /</span><br><span class="line">/dev/sda2            120367992  50171596  64082060  44% /home</span><br><span class="line">使用-h选项可以以更符合阅读习惯的方式显示磁盘使用量</span><br><span class="line"></span><br><span class="line">$ df -h</span><br><span class="line">Filesystem                  Size   Used  Avail Capacity  iused      ifree %iused  Mounted on</span><br><span class="line">/dev/disk0s2               232Gi   84Gi  148Gi    37% 21998562   38864868   36%   /</span><br><span class="line">devfs                      187Ki  187Ki    0Bi   100%      648          0  100%   /dev</span><br><span class="line">map -hosts                   0Bi    0Bi    0Bi   100%        0          0  100%   /net</span><br><span class="line">map auto_home                0Bi    0Bi    0Bi   100%        0          0  100%   /home</span><br><span class="line">/dev/disk0s4               466Gi   45Gi  421Gi    10%   112774  440997174    0%   /Volumes/BOOTCAMP</span><br><span class="line">//app@izenesoft.cn/public  2.7Ti  1.3Ti  1.4Ti    48%        0 18446744073709551615    0%   /Volumes/public</span><br><span class="line">使用-T选项显示文件系统类型</span><br><span class="line"></span><br><span class="line">$ df -T</span><br><span class="line">Filesystem    Type   1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/sda1     ext4    29530400   3233120  24797216  12% /</span><br><span class="line">/dev/sda2     ext4   120367992  50171596  64082060  44% /home</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chmod</span><br><span class="line">chmod用于改变文件和目录的权限</span><br><span class="line"></span><br><span class="line">给指定文件的属主和属组所有权限(包括读、写、执行)</span><br><span class="line"></span><br><span class="line">$ chmod ug+rwx file.txt</span><br><span class="line">删除指定文件的属组的所有权限</span><br><span class="line"></span><br><span class="line">$ chmod g-rwx file.txt</span><br><span class="line">修改目录的权限，以及递归修改目录下面所有文件和子目录的权限</span><br><span class="line"></span><br><span class="line">$ chmod -R ug+rwx file.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chown</span><br><span class="line">chown用于改变文件属主和属组</span><br><span class="line"></span><br><span class="line">同时将某个文件的属主改为oracle，属组改为db</span><br><span class="line"></span><br><span class="line">$ chown oracle:dba dbora.sh</span><br><span class="line">使用-R选项对目录和目录下的文件进行递归修改</span><br><span class="line"></span><br><span class="line">$ chown -R oracle:dba /home/oracle</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在云计算部门实习了一年多了也，从之前的linux操作每一条命令都要百度，到现在的熟练操作，记录总结一下吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>map结构</title>
    <link href="http://yoursite.com/2018/09/28/map%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/09/28/map结构/</id>
    <published>2018-09-28T02:59:32.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>依然是在开发者头条刷到的，看看这些底层原理，感觉对自己很有帮助</p><p>尤其是Map 这样的 Key Value 在软件开发中是非常经典的结构，常用于在内存中存放数据。</p><a id="more"></a><p>从hashmap开始介绍：</p><p>HashMap 底层是基于 数组 + 链表 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同<br><img src="/img/hashmap1.jpg" alt="avatar"><br>1.7中的实现，如图<br><img src="/img/hashmap代码.jpg" alt="avatar"></p><p>这是 HashMap 中比较核心的几个成员变量；看看分别是什么意思？</p><p>初始化桶大小，因为底层是数组，所以这是数组默认的大小。<br>桶最大值。<br>默认的负载因子（0.75）<br>table 真正存放数据的数组。<br>Map 存放数量的大小。<br>桶大小，可在初始化时显式指定。<br>负载因子，可在初始化时显式指定。<br>重点解释下负载因子：</p><p>由于给定的 HashMap 的容量大小是固定的，比如默认初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><p>因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。</p><p>根据代码可以看到其实真正存放数据的是</p><p>transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</p><p>这个数组，那么它又是如何定义的呢？</p><p><img src="/img/entry.jpg" alt="avatar"></p><p>Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出：</p><p>key 就是写入时的键。<br>value 自然就是值。<br>开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。<br>hash 存放的是当前 key 的 hashcode。<br>知晓了基本结构，那来看看其中重要的写入、获取函数：</p><p>put 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前数组是否需要初始化。<br>如果 key 为空，则 put 一个空值进去。<br>根据 key 计算出 hashcode。<br>根据计算出的 hashcode 定位出所在桶。<br>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。<br>如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        hash = (null != key) ? hash(key) : 0;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当调用 addEntry 写入 Entry 时需要判断是否需要扩容。</p><p>如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。</p><p>而在 createEntry 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。</p><p>get 方法<br>再来看看 get 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。<br>判断该位置是否为链表。<br>不是链表就根据 key、key 的 hashcode 是否相等来返回值。<br>为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。<br>啥都没取到就直接返回 null 。</p><p>Base 1.8<br>不知道 1.7 的实现大家看出需要优化的点没有？</p><p>其实一个很明显的地方就是：</p><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 O(N)。</p><p>因此 1.8 中重点优化了这个查询效率。</p><p>1.8 HashMap 结构图：</p><p><img src="/img/hash1.8" alt="avatar"></p><p>先来看看几个核心的成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">/**</span><br><span class="line"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line"> * by either of the constructors with arguments.</span><br><span class="line"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="line"> */</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">/**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> */</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">/**</span><br><span class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="line"> * for keySet() and values().</span><br><span class="line"> */</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">/**</span><br><span class="line"> * The number of key-value mappings contained in this map.</span><br><span class="line"> */</span><br><span class="line">transient int size;</span><br></pre></td></tr></table></figure><p>和 1.7 大体上都差不多，还是有几个重要的区别：</p><p>TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。<br>HashEntry 修改为 Node。<br>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 key value hashcode next 等数据。</p><p>再来看看核心方法。</p><p>put 方法</p><p><img src="/img/1.8hashput" alt="avatar"></p><p>看似要比 1.7 的复杂，我们一步步拆解：</p><p>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。<br>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。<br>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e,在第 8 步的时候会统一进行赋值及返回。<br>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。<br>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。<br>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。<br>如果在遍历过程中找到 key 相同时直接退出遍历。<br>如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。<br>最后判断是否需要进行扩容。<br>get 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 方法看起来就要简单许多了。</p><p>首先将 key hash 之后取得所定位的桶。<br>如果桶为空则直接返回 null 。<br>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。<br>如果第一个不匹配，则判断它的下一个是红黑树还是链表。<br>红黑树就按照树的查找方式返回值。<br>不然就按照链表的方式遍历匹配返回值。<br>从这两个核心方法（get/put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 O(logn)。</p><p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p><figure class="highlight plain"><figcaption><span>HashMap<string, string=""> map </string,></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            map.put(UUID.randomUUID().toString(), &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是为什么呢？简单分析下。</p><p>看过上文的还记得在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p><p>如下图：</p><p><img src="/img/hashmapbingfa1.jpg" alt="avatar"><br><img src="/img/hashmapbingfa2.jpg" alt="avatar"></p><p>遍历方式<br>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + next.getKey() + &quot; value=&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + key + &quot; value=&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>强烈建议使用第一种 EntrySet 进行遍历。</p><p>第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><p>简单总结下 HashMap：无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。</p><p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 java.util.concurrent 包下，专门用于解决并发问题。</p><p>坚持看到这里的朋友算是已经把 ConcurrentHashMap 的基础已经打牢了，下面正式开始分析</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依然是在开发者头条刷到的，看看这些底层原理，感觉对自己很有帮助&lt;/p&gt;
&lt;p&gt;尤其是Map 这样的 Key Value 在软件开发中是非常经典的结构，常用于在内存中存放数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>golang中的json转换</title>
    <link href="http://yoursite.com/2018/09/26/golang%E4%B8%AD%E7%9A%84json%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/09/26/golang中的json转换/</id>
    <published>2018-09-26T10:02:13.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一个项目遇到的最多的一个问题就是使用json的时候不能确定业务方发来的数据是整形还是字符串类型</p><p>现在找到了一个比较简单的方法优雅的解决掉这个问题<br><!-- more -- >首先定义一个结构体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Host struct &#123;</span><br><span class="line">    Name string `json:&quot;name&quot;`</span><br><span class="line">    Port Port   `json:&quot;port&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>心细的你会发现，Port既不是int也不是string类型，而是Port类型，而Port类型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Type int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Int Type = iota</span><br><span class="line">    String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Port struct &#123;</span><br><span class="line">    Type   Type</span><br><span class="line">    IntVal int</span><br><span class="line">    StrVal string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Port结构体中，我们发现了Type类型， 而Type类型包括了int,string两种类型。接下来就非常重要了，我们需要实现以下这两个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json.Unmarshaller interface</span><br><span class="line">json.Marshaller interface</span><br></pre></td></tr></table></figure></p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type Port struct &#123;</span><br><span class="line">    Type   Type</span><br><span class="line">    IntVal int</span><br><span class="line">    StrVal string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现 json.Unmarshaller 接口</span><br><span class="line">func (port *Port) UnmarshalJSON(value []byte) error &#123;</span><br><span class="line">    if value[0] == &apos;&quot;&apos; &#123;</span><br><span class="line">        port.Type = String</span><br><span class="line">        return json.Unmarshal(value, &amp;port.StrVal)</span><br><span class="line">    &#125;</span><br><span class="line">    port.Type = Int</span><br><span class="line">    return json.Unmarshal(value, &amp;port.IntVal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现 json.Marshaller 接口</span><br><span class="line">func (port Port) MarshalJSON() ([]byte, error) &#123;</span><br><span class="line">    switch port.Type &#123;</span><br><span class="line">    case Int:</span><br><span class="line">        return json.Marshal(port.IntVal)</span><br><span class="line">    case String:</span><br><span class="line">        return json.Marshal(port.StrVal)</span><br><span class="line">    default:</span><br><span class="line">        return []byte&#123;&#125;, fmt.Errorf(&quot;impossible Port.Type&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的数据结构可以这样解决吧。算是一种方法。</p>--></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一个项目遇到的最多的一个问题就是使用json的时候不能确定业务方发来的数据是整形还是字符串类型&lt;/p&gt;
&lt;p&gt;现在找到了一个比较简单的方法优雅的解决掉这个问题&lt;br&gt;&lt;!-- more -- &gt;
首先定义一个结构体
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
    
      <category term="golang 博客" scheme="http://yoursite.com/tags/golang-%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>什么是dp，dp的意义何在</title>
    <link href="http://yoursite.com/2018/09/26/%E4%BB%80%E4%B9%88%E6%98%AFdp%EF%BC%8Cdp%E7%9A%84%E6%84%8F%E4%B9%89%E4%BD%95%E5%9C%A8/"/>
    <id>http://yoursite.com/2018/09/26/什么是dp，dp的意义何在/</id>
    <published>2018-09-26T08:24:45.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天逛知乎的时候看到了 一个关于动态规划的提问，遇到了两个超级棒的回答。记录在下。<br>参考知乎 作者：王勐 徐凯强Andy<br>动态规划的本质，是对问题状态的定义和状态转移方程的定义。另外在最后提供了一种解决最长递增子序列的解法。<br><a id="more"></a><br>动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p><p>如何拆分问题，才是动态规划的核心。</p><ol><li>什么是状态的定义？</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个数列，长度为N，</span><br><span class="line">求这个数列的最长上升（递增）子数列（LIS）的长度.</span><br><span class="line">以</span><br><span class="line">1 7 2 8 3 4</span><br><span class="line">为例。</span><br><span class="line">这个数列的最长递增子数列是 1 2 3 4，长度为4；</span><br><span class="line">次长的长度为3， 包括 1 7 8; 1 2 3 等.</span><br></pre></td></tr></table></figure><p>首先要定义这个问题和这个问题的子问题。</p><p>新问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所以我们来重新定义这个问题：</span><br><span class="line">给定一个数列，长度为N，</span><br><span class="line">设F_&#123;k&#125;为：以数列中第k项结尾的最长递增子序列的长度.</span><br><span class="line">求F_&#123;1&#125;..F_&#123;N&#125; 中的最大值.</span><br></pre></td></tr></table></figure></p><p>而对于F_{k}来讲，F_{1} .. F_{k-1}都是F_{k}的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第1..k-1中某项结尾的LIS。</p><p>上述的新问题F_{k}也可以叫做状态，定义中的“F_{k}为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。</p><ol start="2"><li>什么是状态转移方程？</li></ol><p>状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程。</p><p>比如，对于LIS问题，我们的第一种定义：<br>设F_{k}为：以数列中第k项结尾的最长递增子序列的长度.</p><p>设A为题中数列，状态转移方程为：<br>F_{1} = 1 （根据状态定义导出边界情况）<br>F_{k}=max(F_{i}+1 | A_{k}&gt;A_{i}, i属于 (1..k-1)) (k&gt;1)<br>用文字解释一下是：<br>以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。</p><p>这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。<br>可以看出，状态转移方程就是带有条件的递推式。</p><ol start="3"><li>动态规划迷思</li></ol><p>a. “缓存”，“重叠子问题”，“记忆化”：这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。都不是动态规划的本质，不是动态规划的核心。</p><p>b. “递归”：<br>递归是递推式求解的方法，连技巧都算不上。</p><p>c. “无后效性”，“最优子结构”：上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是”无后效性”的通俗上的数学定义，符合这种定义的状态定义，我们可以说它具有“最优子结构”的性质，在动态规划中我们要做的，就是找到这种“最优子结构”。在对状态和状态转移方程的定义过程中，满足“最优子结构”是一个隐含的条件（否则根本定义不出来）。对状态和“最优子结构”的关系的进一步解释，</p><p>举一个简单例子：</p><p>比如说我想计算第100个非波那契数，每一个非波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。</p><p>比如说我想计算第100个非波那契数，每一个非波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。</p><p>非波那契那个例子过于简单，以至于让人忽视了阶段的概念，所谓阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合。非波那契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。想象另外一个问题情景，假如把你放在一个围棋棋盘上的某一点，你每一步只能走一格，因为你可以东南西北随便走，所以你当你同样走四步可能会处于很多个不同的位置。从头开始走了几步就是第几个阶段，走了n步可能处于的位置称为一个状态，走了这n步所有可能到达的位置的集合就是这个阶段下所有可能的状态。现在问题来了，有了阶段之后，计算新状态可能会遇到各种奇葩的情况，针对不同的情况，就需要不同的算法，下面就分情况来说明一下：</p><p>假如问题有n个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。好消息是，有时候我们并不需要真的计算所有状态，比如这样一个弱智的棋盘问题：从棋盘的左上角到达右下角最短需要几步。答案很显然，用这样一个弱智的问题是为了帮助我们理解阶段和状态。某个阶段确实可以有多个状态，正如这个问题中走n步可以走到很多位置一样。但是同样n步中，有哪些位置可以让我们在第n+1步中走的最远呢？没错，正是第n步中走的最远的位置。换成一句熟悉话叫做“下一步最优是从当前最优得到的”。所以为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫贪心。如果只看最优状态之间的计算过程是不是和非波那契数列的计算很像？所以计算的方法是递推。</p><p>既然问题都是可以划分成阶段和状态的。这样一来我们一下子解决了一大类问题：一个阶段的最优可以由前一个阶段的最优得到。</p><p>如果一个阶段的最优无法用前一个阶段的最优得到呢？</p><p>什么你说只需要之前两个阶段就可以得到当前最优？那跟只用之前一个阶段并没有本质区别。最麻烦的情况在于你需要之前所有的情况才行。再来一个迷宫的例子。在计算从起点到终点的最短路线时，你不能只保存当前阶段的状态，因为题目要求你最短，所以你必须知道之前走过的所有位置。因为即便你当前再的位置不变，之前的路线不同会影响你的之后走的路线。这时你需要保存的是之前每个阶段所经历的那个状态，根据这些信息才能计算出下一个状态！每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的。哦哦，刚刚提到的之前的路线会影响到下一步的选择，这个令人不开心的情况就叫做有后效性。</p><p>刚刚的情况实在太普遍，解决方法实在太暴力，有没有哪些情况可以避免如此的暴力呢？契机就在于后效性。有一类问题，看似需要之前所有的状态，其实不用。不妨也是拿最长上升子序列的例子来说明为什么他不必需要暴力搜索，进而引出动态规划的思路。假装我们年幼无知想用搜索去寻找最长上升子序列。怎么搜索呢？需要从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚迷宫找路的影子！咦慢着，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较就行了！这是和之前迷宫问题的本质不同！这就可以纵容我们不需要记录之前所有的状态啊！既然我们的选择已经不受之前状态的组合的影响了，那时间复杂度自然也不是指数的了啊！虽然我们不在乎某序列之前都是什么元素，但我们还是需要这个序列的长度的。所以我们只需要记录以某个元素结尾的LIS长度就好！因此第i个阶段的最优解只是由前i-1个阶段的最优解得到的，然后就得到了DP方程<br>LIS(i)=max{LIS(j)+1} j&lt; i and a[j] &lt; a[i]所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！<br>所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！每个阶段只有一个状态-&gt;递推；每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做最优子结构；而不管之前这个状态是如何得到的这个性质叫做无后效性。另：其实动态规划中的最优状态的说法容易产生误导，以为只需要计算最优状态就好，LIS问题确实如此，转移时只用到了每个阶段“选”的状态。但实际上有的问题往往需要对每个阶段的所有状态都算出一个最优值，然后根据这些最优值再来找最优状态。比如背包问题就需要对前i个包（阶段）容量为j时（状态）计算出最大价值。然后在最后一个阶段中的所有状态种找到最优值。</p><p>#最长递增子序列问题：</p><p>如果存在某个数字X比某个已有的递增子序列的最后一个元素E要大，且X在E的右边，那么X就可以添加到这个递增子序列的末尾，从而使递增子序列的长度更大。</p><p>随意想一个数列。1，9，2，3，8，5，7，4</p><p>这样下来就是1，2，3，5，7<br>长度为5</p><p>我们如何找到呢。。</p><p>只考虑最后一次搜索的情况下，那么我们扫描到7 也就是要找到之前的最长子序列，1，2，3，8或者1，2，3，5，要满足两个条件，<br>1，之前的子序列要小于7，<br>2，之前的子序列都在7的左边。</p><p>也就是那些结尾元素比当前元素小且在当前元素左边的LIS</p><p>从动态规划的角度看，一个较大的父问题被分解为了两个较小的子问题，且父问题和子问题是同一种问题。既然我们已经可以递归地找到以X结尾的LIS，为了利用这一点，我们就将整个问题转化为：对于输入序列中的每个元素X，分别找出找出以X结尾的LIS，其中长度最长的，就是我们要找的最终LIS。</p><p>动态规划进一步要求问题的解决顺序，先解决较小的问题，然后用较小问题的答案来解决较大的问题，而不要使用递归的方式。看下面的代码实现。</p><p>之后看代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  int lengthOfLIS(vector&lt;int&gt; &amp;nums)</span><br><span class="line">  &#123;</span><br><span class="line">    const int size = nums.size();</span><br><span class="line">    if (size &lt; 1)</span><br><span class="line">      return 0;</span><br><span class="line">    int max_length = 1;</span><br><span class="line">    // lengthOfLISEndAtI[i]存储了：以nums[i]结尾的LIS的长度。</span><br><span class="line">    vector&lt;int&gt; lengthOfLISEndAtI(size, 1);</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      // 当前扫描到的元素是nums[i]</span><br><span class="line">      for (int j = 0; j &lt; i; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        // 找出那些在nums[i]左边且比nums[i]小的元素</span><br><span class="line">        if (nums[j] &gt;= nums[i])</span><br><span class="line">          continue;</span><br><span class="line">        // 以nums[j]结尾的LIS与nums[i]组合，是否能产生更长的LIS（以nums[i]结尾）</span><br><span class="line">        if (lengthOfLISEndAtI[i] &lt; lengthOfLISEndAtI[j] + 1)</span><br><span class="line">        &#123;</span><br><span class="line">          lengthOfLISEndAtI[i] = lengthOfLISEndAtI[j] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 以哪个元素结尾的LIS最长</span><br><span class="line">      if (max_length &lt; lengthOfLISEndAtI[i])</span><br><span class="line">      &#123;</span><br><span class="line">        max_length = lengthOfLISEndAtI[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此算法的时间复杂度是O(n^2)。用了2层嵌套循环：</p><p>外层循环用来逐个扫描输入，假设当前扫描到的元素是X<br>内层循环用来找出在X的左边（也就是已经扫描过的），且值比X小的元素E，使X能拼接到以E结尾的LIS的后面。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天逛知乎的时候看到了 一个关于动态规划的提问，遇到了两个超级棒的回答。记录在下。&lt;br&gt;参考知乎 作者：王勐 徐凯强Andy&lt;br&gt;动态规划的本质，是对问题状态的定义和状态转移方程的定义。另外在最后提供了一种解决最长递增子序列的解法。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>tcp udp http</title>
    <link href="http://yoursite.com/2018/09/26/tcp-udp-http/"/>
    <id>http://yoursite.com/2018/09/26/tcp-udp-http/</id>
    <published>2018-09-26T02:11:32.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲的是http和tcp的关系 在最后复习一下http和udp的区别以及应用</p><a id="more"></a><p>先说一下之前的误解，<br>一直以为，或者是去年之前一直以为tcp和http没什么关系，是独立的两个协议。</p><p>#http协议是基于tcp协议的<br>这样说：tcp只是用来建立连接的 而http协议是传送数据的，实际应用中就是我们设计的restful API以及传输的json数据。</p><p>首先 传输层 三次握手建立tcp连接</p><p>建立连接完成后使用http协议传输数据<br>比如我们浏览网页是这样的：<br>浏览器 发送一个http请求给server。收到请求后，响应浏览器。浏览器把这些数据渲染成为了网页，展示在用户面前。</p><p>TCP是底层通讯协议，定义的是数据传输和连接方式的规范<br>HTTP是应用层协议，定义的是传输数据的内容的规范<br>HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP</p><p>HTTP支持的是www服务<br>而TCP/IP是协议<br>它是Internet国际互联网络的基础。TCP/IP是网络中使用的基本的通信协议。<br>TCP/IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP／IP是Internet协议族，而不单单是TCP和IP。</p><p>写到这里大概就清楚了。。可是现在习惯性的翻开知乎果然又有让我惊喜的答案。用这种大白话收尾http与tcp关系吧。</p><p>作者：老司机<br>链接：<a href="https://www.zhihu.com/question/38648948/answer/241629093" target="_blank" rel="noopener">https://www.zhihu.com/question/38648948/answer/241629093</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>下个月你就要结婚了，打个电话给老王。你先打开电话本，查找“老王”的电话号码：老王 -&gt; 13987654321（DNS解析）。然后你用手机拨打了13987654321（IP）。你的手机连接到了联通的基站（路由器），联通（你自己的网关）发现这是个移动的手机号，通过移动的帮助，找到了老王的手机（MAC），老王的手机开始响铃。“嘟……”（TCP握手）-“喂？老绿啊！”“哈哈，是我啊，老王！（连接建立）下个月我结婚，你有空吗？”（开始传输数据，先说事）“噢，有啊！”-“那你记一下地址啊（再说时间地点）！北京市东长安街16号午门太和殿。”“诶，你慢点说（流量控制），我记一下。”-“北京市”（缩小了滑动窗口）“嗯，然后呢？”（ACK）“东长安街16号”“东……16号”（ACK）-“午门太和殿”“午门（ACK“午门”）什么殿？你再说一遍，我没听清！”（“太和殿”传输失败，数据包丢失）-“太和殿”（重传）“好！记下了”（传输成功）-“那回见啊！”（准备断开连接）“好嘞！”【通话已结束】（连接断开）刚才的例子实际上传递了一段信息：我下个月结婚。HTTP只是信息的载体，刚才说的“汉语”就是HTTP。你也可以用其他协议传递，比如“I’m getting married next month”，只要对方能理解协议，那就是同一个意思。电话线路相当于一个TCP连接。TCP提供了流量控制、数据重传等机制保证了数据可靠顺序传输。当然这个例子中，可靠传输是靠人来保证的。HTTP和TCP的联系，是HTTP（要结婚的消息）使用TCP（电话）提供的“传输能力”。除此之外，没了。很多答案都提到了，网络协议是一个栈，提供对等通信。这里解释下对等。老王和老绿只与电话发生交互，他们不理解声音如何转换成电信号，也不理解电磁波如何传播。他们只知道，我对着电话说汉语，对方就能听到汉语。老王和老绿就是一个对等的协议层。两部电话也是对等的协议层，它们给上面的老王和老绿提供传输语音的服务。而电话提供的服务，底层又依赖电磁波传递无线信号。最后形成了一个个服务层，完成了打电话这个事情。再举个栗子，两个老板要约时间谈生意，他们会跟自己的秘书下达指令，让秘书搞定约会这个事。双方的秘书会互相联系，约好时间地点和司机，最后搞定这个问题。老板们不会跟对方的秘书联系（除非是小老板对马老板，那他们实际上就是不对等的），因为他们不是一个层的。把上文层次的概念，放到计算机网络中，就是协议栈。协议栈的每一层，都专注于自己层的事情：HTTP专注于要传输的信息（HTTP是信息的载体，所以在协议里面会标注信息长度，信息类型等），TCP专注于传输的可靠（为了可靠传输，TCP会给自己层的包标注大小和顺序，并且有确认机制），IP负责因特网传输（IP也有自己的格式，自己查吧），再下面的层负责与局域网和硬件打交道。简单来说，网络协议栈里面，每层都解决了计算机通信流程的某一环节的问题。它们使用下层提供的能力跟对方机器的相应协议层通信，给上层提供自己的服务。最后，TCP的下层是IP。“我下个月结婚”这几个字，你也可以通过短信（UDP）或微信（其他传输协议）来发送。虽然传输层协议不一样（电话 vs 短信），底层还是依赖IP协议（发短信仍然需要知道对方的电话号码）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲的是http和tcp的关系 在最后复习一下http和udp的区别以及应用&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>redis面试</title>
    <link href="http://yoursite.com/2018/09/25/redis%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2018/09/25/redis面试/</id>
    <published>2018-09-25T12:09:23.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理的一些关于redis入门以及面试的东西</p><a id="more"></a><p>#1. 简介<br>单线程为什么这么快？</p><p>纯内存<br>非阻塞IO<br>避免线程切换和竞争消耗<br>单线程Redis注意事项</p><p>一次只运行一条命令</p><p>拒绝长（慢）命令，例如：keys、flushall、flushdb、slow lua script、mutil/exec、operate big value(collection)</p><p>Redis其实不是单线程，fysnc file descriptor进行持久化</p><p>特性</p><p>速度快<br>持久化<br>多钟数据结构<br>支持多种编程语言<br>功能丰富<br>简单<br>主从复制<br>高可用，分布式</p><p>#2. 应用场景<br>缓存系统</p><p>排行版</p><p>计数器</p><p>社交网络</p><p>消息队列系统</p><p>实时系统</p><p>#3. 数据类型</p><p>redis</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理的一些关于redis入门以及面试的东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>算法思想-排序部分</title>
    <link href="http://yoursite.com/2018/09/25/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2018/09/25/算法思想/</id>
    <published>2018-09-25T10:45:21.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>从排序说起：</p><a id="more"></a><p>1，选择排序<br><img src="/img/选择排序.gif" alt="avatar"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(int[] arr) &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        // 寻找[i, n)区间里的最小值的索引</span><br><span class="line">        int minIndex = i;</span><br><span class="line">        for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">            if(arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap( arr , i , minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>，最简单的例子 冒泡排序<br><img src="/img/冒泡排序.gif" alt="avatar"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(int[] arr) &#123;</span><br><span class="line">    for (int i = arr.length - 1; i &gt; 0; i--) &#123; // 从最后一位开始确定</span><br><span class="line">        boolean swapped = false;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                swapped = true;</span><br><span class="line">                swap(arr,j,j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!swapped)</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><ol start="2"><li>插入排序（Insertion Sort）最简单的例子：平时玩扑克牌的时候插入排序<br><img src="/img/插入排序.gif" alt="avatar"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(int[] arr) &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for (int j = i + 1; j &gt; 0; j--) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[j - 1])</span><br><span class="line">                swap(arr, j, j - 1); // 大量的交换会消耗时间</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>另一种改进的减少了数组元素的操作次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 改进版插入排序（减少了数组元素的操作次数）</span><br><span class="line">public static void better_sort(int[] arr) &#123;</span><br><span class="line">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        int e = arr[i];</span><br><span class="line">        int j = i;</span><br><span class="line">        for (; j &gt; 0; j--) &#123;</span><br><span class="line">            if (e &lt; arr[j - 1])</span><br><span class="line">                arr[j] = arr[j - 1];</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>3,希尔排序（Shell Sort）（为什么可以突破n2）<br>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><img src="/img/希尔排序.gif" alt="avatar"><br>算法描述</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(int[] arr) &#123;</span><br><span class="line">    int n = arr.length;</span><br><span class="line">    for (int h = n / 2; h &gt; 0; h = h / 2) &#123;</span><br><span class="line">        // 内部是一个插入排序</span><br><span class="line">        for (int i = 0; i &lt; n; i = i + h) &#123;</span><br><span class="line">            int e = arr[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            for (; j &gt; 0; j = j - h) &#123;</span><br><span class="line">                if (e &lt; arr[j - h])</span><br><span class="line">                    arr[j] = arr[j - h];</span><br><span class="line">                else</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种方式要计算步长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void sort2(int[] arr) &#123;</span><br><span class="line">    int n = arr.length;</span><br><span class="line">    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...</span><br><span class="line">    int h = 1;</span><br><span class="line">    while (h &lt; n / 3) h = 3 * h + 1;</span><br><span class="line"></span><br><span class="line">        System.out.println(h);</span><br><span class="line">        while (h &gt;= 1) &#123;</span><br><span class="line">            // h-sort the array</span><br><span class="line">            for (int i = h; i &lt; n; i++) &#123;</span><br><span class="line">                // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序</span><br><span class="line">                int e = arr[i];</span><br><span class="line">                int j = i;</span><br><span class="line">                for (; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)</span><br><span class="line">                    arr[j] = arr[j - h];</span><br><span class="line">                arr[j] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= 3;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。</p><p>希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><p>#为了改进插入排序的这种局限性</p><ol start="4"><li>归并排序（Merge Sort）<br><img src="/img/归并排序.gif" alt="avatar"><br>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(int[] arr) &#123;</span><br><span class="line">    __MergeSort(arr, 0, arr.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void __MergeSort(int[] arr, int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r)</span><br><span class="line">        return;</span><br><span class="line">    int mid = (l + r) / 2;</span><br><span class="line">    __MergeSort(arr, l, mid);</span><br><span class="line">    __MergeSort(arr, mid + 1, r);</span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将arr[l...mid]和arr[mid+1...r]两部分进行归并</span><br><span class="line">private static void merge(int[] arr, int l, int mid, int r) &#123;</span><br><span class="line">    int[] aux = Arrays.copyOfRange(arr, l, r + 1);</span><br><span class="line"></span><br><span class="line">    // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span><br><span class="line">    int i = l, j = mid + 1;</span><br><span class="line">    for (int k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        if (i &gt; mid) &#123;  // 如果左半部分元素已经全部处理完毕</span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else if (j &gt; r) &#123;   // 如果右半部分元素已经全部处理完毕</span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else if (aux[i - l] &lt; aux[j - l]) &#123;  // 左半部分所指元素 &lt; 右半部分所指元素</span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;  // 左半部分所指元素 &gt;= 右半部分所指元素</span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>5，快速排序<br>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。<br><img src="/img/快速排序.gif" alt="avatar"><br>快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p><p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 递归使用快速排序,对arr[l...r]的范围进行排序</span><br><span class="line">public static void QuickSort(int[] arr,int l,int r)&#123;</span><br><span class="line">    if(l&gt;=r)</span><br><span class="line">        return;</span><br><span class="line">    int p = partition(arr,l,r);</span><br><span class="line">    QuickSort(arr,l,p-1);</span><br><span class="line">    QuickSort(arr,p+1,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将数组通过p分割成两部分</span><br><span class="line">// 对arr[l...r]部分进行partition操作</span><br><span class="line">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span><br><span class="line">public static int partition(int[] arr, int l, int r) &#123;</span><br><span class="line">    swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);  // 加入这一行变成随机快速排序</span><br><span class="line"></span><br><span class="line">    int v = arr[l];</span><br><span class="line">    int j = l;</span><br><span class="line">    for(int i = j +1;i&lt;=r;i++)&#123;</span><br><span class="line">        if(arr[i] &lt; v)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr,l,j);</span><br><span class="line">    //只能确定左边都比他小</span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] arr,int i,int j) &#123;</span><br><span class="line">    int temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>双路的快速排序<br><img src="/img/双路快速排序.jpg" alt="avatar"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 双路快速排序的partition</span><br><span class="line">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span><br><span class="line">private static int partition(int[] arr, int l, int r) &#123;</span><br><span class="line"></span><br><span class="line">    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span><br><span class="line">    // swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);</span><br><span class="line"></span><br><span class="line">    int v = arr[l];</span><br><span class="line"></span><br><span class="line">    // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v</span><br><span class="line">    int i = l + 1, j = r;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0</span><br><span class="line">        // 思考一下为什么?</span><br><span class="line">        while (i &lt;= r &amp;&amp; arr[i] &lt; v)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        // 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0</span><br><span class="line">        // 思考一下为什么?</span><br><span class="line">        while (j &gt;= l + 1 &amp;&amp; arr[j] &gt; v)</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)</span><br><span class="line">        // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html</span><br><span class="line">        if (i &gt; j)</span><br><span class="line">            break;</span><br><span class="line">        </span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归使用快速排序,对arr[l...r]的范围进行排序</span><br><span class="line">private static void QuickSort2Ways(int[] arr, int l, int r) &#123;</span><br><span class="line">    // 对于小规模数组, 使用插入排序</span><br><span class="line">    if (l &gt;= r) return;</span><br><span class="line">    int p = partition(arr, l, r);</span><br><span class="line">    QuickSort2Ways(arr, l, p - 1);</span><br><span class="line">    QuickSort2Ways(arr, p + 1, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6，堆排序（Heap Sort）</p><ol><li>堆<br>堆的某个节点的值总是大于等于子节点的值，并且堆是一颗完全二叉树。</li></ol><p>堆可以用数组来表示，因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p><ol start="2"><li>上浮和下沉<br>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮（ShiftUp）。</li></ol><p><img src="/img/heap1.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void shiftUp(int k)&#123;</span><br><span class="line">    while( k &gt; 1 &amp;&amp; data[k/2] &lt; data[k]))&#123;</span><br><span class="line">        swap(k, k/2);</span><br><span class="line">        k /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉（Shift Down）。一个节点如果有两个子节点，应当与两个子节点中最大那么节点进行交换。<br><img src="/img/heap2.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void shiftDown(int k)&#123;</span><br><span class="line">    while( 2*k &lt;= count )&#123; // 当前结点有左孩子</span><br><span class="line">        int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置</span><br><span class="line">        if( j+1 &lt;= count &amp;&amp; data[j+1] &gt; data[j] )</span><br><span class="line">            j ++;</span><br><span class="line">        // data[j] 是 data[2*k]和data[2*k+1]中的最大值</span><br><span class="line"></span><br><span class="line">        if( data[k] &gt;= data[j] ) </span><br><span class="line">            break;</span><br><span class="line">        swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.插入元素<br>将新元素放到数组末尾，然后上浮到合适的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 向最大堆中插入一个新的元素 item</span><br><span class="line">public void insert(Item item)&#123;</span><br><span class="line">    assert count + 1 &lt;= capacity;</span><br><span class="line">    data[count+1] = item;</span><br><span class="line">    count ++;</span><br><span class="line">    shiftUp(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>删除最大元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span><br><span class="line">public Item extractMax()&#123;</span><br><span class="line">    assert count &gt; 0;</span><br><span class="line">    Item ret = data[1];</span><br><span class="line">    </span><br><span class="line">    swap( 1 , count );</span><br><span class="line">    count --;</span><br><span class="line">    shiftDown(1);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>堆排序</p></li></ol><p>由于堆可以很容易得到最大的元素并删除它，不断地进行这种操作可以得到一个递减序列。如果把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列。因此很容易使用堆来进行排序。并且堆排序是原地排序，不占用额外空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">    // 对整个arr数组使用HeapSort1排序</span><br><span class="line">    // HeapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span><br><span class="line">    // 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span><br><span class="line">    // 整个堆排序的整体时间复杂度为O(nlogn)</span><br><span class="line">    public static void sort1(Comparable[] arr)&#123;</span><br><span class="line"></span><br><span class="line">        int n = arr.length;</span><br><span class="line">        MaxHeap&lt;Comparable&gt; maxHeap = new MaxHeap&lt;Comparable&gt;(n);</span><br><span class="line">        for( int i = 0 ; i &lt; n ; i ++ )</span><br><span class="line">            maxHeap.insert(arr[i]);</span><br><span class="line"></span><br><span class="line">        for( int i = n-1 ; i &gt;= 0 ; i -- )</span><br><span class="line">            arr[i] = maxHeap.extractMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 只通过shiftDown操作进行排序</span><br><span class="line">    public static void sort2(Comparable[] arr)&#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line"></span><br><span class="line">        // 注意，此时我们的堆是从0开始索引的</span><br><span class="line">        // 从(最后一个元素的索引-1)/2开始</span><br><span class="line">        // 最后一个元素的索引 = n-1</span><br><span class="line">        for( int i = (n-1-1)/2 ; i &gt;= 0 ; i -- )</span><br><span class="line">            shiftDown2(arr, n, i);</span><br><span class="line"></span><br><span class="line">        for( int i = n-1; i &gt; 0 ; i-- )&#123; // 这个的目的是让序列从小到大排序</span><br><span class="line">            swap( arr, 0, i);</span><br><span class="line">            shiftDown2(arr, i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 交换堆中索引为i和j的两个元素</span><br><span class="line">    private static void swap(Object[] arr, int i, int j)&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 原始的shiftDown过程</span><br><span class="line">    private static void shiftDown(Comparable[] arr, int n, int k)&#123;</span><br><span class="line">        while( 2*k+1 &lt; n )&#123;</span><br><span class="line">            int j = 2*k+1;</span><br><span class="line">            if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )</span><br><span class="line">                j += 1;</span><br><span class="line"></span><br><span class="line">            if( arr[k].compareTo(arr[j]) &gt;= 0 )break;</span><br><span class="line"></span><br><span class="line">            swap( arr, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 优化的shiftDown过程, 使用赋值的方式取代不断的swap,</span><br><span class="line">    // 该优化思想和我们之前对插入排序进行优化的思路是一致的</span><br><span class="line">    private static void shiftDown2(Comparable[] arr, int n, int k)&#123;</span><br><span class="line"></span><br><span class="line">        Comparable e = arr[k];</span><br><span class="line">        while( 2*k+1 &lt; n )&#123;</span><br><span class="line">            int j = 2*k+1;</span><br><span class="line">            if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )</span><br><span class="line">                j += 1;</span><br><span class="line"></span><br><span class="line">            if( e.compareTo(arr[j]) &gt;= 0 )</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            arr[k] = arr[j];</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[k] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试 HeapSort</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] arr = &#123;10, 91, 8, 7, 6, 5, 4, 3, 2, 1&#125;;</span><br><span class="line">        HeapSort.sort2(arr);</span><br><span class="line">        PrintHelper.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从排序说起：&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>职业规划</title>
    <link href="http://yoursite.com/2018/09/25/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2018/09/25/职业规划/</id>
    <published>2018-09-25T02:44:52.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>读了美团大大的一篇文章受益匪浅  记录到这里。原文链接：<a href="https://mp.weixin.qq.com/s/xBEYqEUKIMRHVvRxkH1hFQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xBEYqEUKIMRHVvRxkH1hFQ</a></p><a id="more"></a><p>每个人都应该有自己的原则，当我们需要作出选择时，一定要坚持以原则为中心。<br>                                                《原则》  桥水基金创始人雷·达里奥</p><p>原则一：Owner意识</p><p>“Owner意识”主要体现在两个层面：一是认真负责的态度，二是积极主动的精神。</p><p>认真负责是工作的底线。积极主动是“Owner意识”更高一级的要求。</p><p>原则二：时间观念</p><p>做事有计划，工作分主次。<br>可以尝试使用“艾森豪威尔法则”（四象限法则），把工作按照重要、紧急程度分成四象限。优先做重要紧急的事情；重要不紧急的事情可以暂缓做，但是要持续推进；紧急不重要的事情可以酌情委托给最合适的人做；不重要不紧急的事情可以考虑不做。</p><p>原则三：以终为始</p><p>“以终为始”（Begin With The End In Mind），是史蒂芬·柯维在《高效能人士的七个习惯》中提到的一个习惯。它是以所有事物都经过两次创造的原则（第一次为心智上的创造，第二次为实际的创造）为基础的。直观的表达就是：先想清楚目标，然后努力实现。</p><p>原则四：闭环思维<br>你是否遇到过这样的场景：参加了一个设计（或需求）评审，大家兴致勃勃地提了很多合理的意见，等到再次评审的时候，却发现第一次提的很多问题都没有得到改进，很多讨论过的问题需要从头再开始讨论。这种情况就是一种典型的工作不闭环。</p><p>真正的闭环，要求我们对工作中的事情都能够养成良好的思维习惯，沟通要有结论，通知要有反馈，To Do要有验收。<br>“闭环思维”还要求能够定期主动进行阶段性的反馈。</p><p>原则五：保持敬畏</p><p>当我们进入到一个新的团队，请先暂时忘掉之前的习惯，要尽快学习团队既有的规范，并且让自己与团队保持一致。让规范与约定与时俱进，也是另一种形式的敬畏。</p><p>原则六：事不过二</p><p>原则七：设计优先<br>“设计优先”这条原则，相对来说更加具体一些。之所以单列一项，是因为架构设计太重要了。Uncle Bob曾说过：“软件架构的目标，是为了让构建与维护系统的所需人力资源最小化。”</p><p>原则八：善于提问<br>“善于提问”，首先要勤于提问。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读了美团大大的一篇文章受益匪浅  记录到这里。原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/xBEYqEUKIMRHVvRxkH1hFQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/xBEYqEUKIMRHVvRxkH1hFQ&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="职业规划" scheme="http://yoursite.com/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>性能剖析</title>
    <link href="http://yoursite.com/2018/09/19/%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/19/性能剖析/</id>
    <published>2018-09-19T05:59:07.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一次使用go语言开发iam，接口、logic、manager写了很多，但是从来没有考虑过性能，开发完成后，对另一个小哥的工作很感兴趣，一下大概介绍一下 使用go语言开发项目的性能优化</p><a id="more"></a><hr><p>PProf<br>首先介绍go语言的性能分析利器 Go 自身提供的工具链</p><p>runtime/pprof：采集程序（非 Server）的运行数据进行分析<br>net/http/pprof：采集 HTTP Server 的运行时数据进行分析</p><hr><p>pprof 是用于可视化和分析性能分析数据的工具</p><p>pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）</p><p>profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式</p><p>支持什么使用模式<br>Report generation：报告生成<br>Interactive terminal use：交互式终端使用<br>Web interface：Web 界面<br>可以做什么<br>CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置<br>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏<br>Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置<br>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况</p><hr><p>首先介绍一下这个工具如何使用，最后再介绍pprog在本工程中的使用</p><p>（1）demo.go，文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">    _ &quot;net/http/pprof&quot;</span><br><span class="line">    &quot;github.com/EDDYCJY/go-pprof-example/data&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            log.Println(data.Add(&quot;https://github.com/EDDYCJY&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    http.ListenAndServe(&quot;0.0.0.0:6060&quot;, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）data/d.go，文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package data</span><br><span class="line"></span><br><span class="line">var datas []string</span><br><span class="line"></span><br><span class="line">func Add(str string) string &#123;</span><br><span class="line">    data := []byte(str)</span><br><span class="line">    sData := string(data)</span><br><span class="line">    datas = append(datas, sData)</span><br><span class="line"></span><br><span class="line">    return sData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行这个文件，你的 HTTP 服务会多出 /debug/pprof 的 endpoint 可用于观察应用程序的情况</p><p>分析</p><p>前两种方式基本一样，以第二种为例进行详细讲解。<br>一、通过 Web 界面<br>查看当前总览：访问 <a href="http://127.0.0.1:6060/debug/pprof/" target="_blank" rel="noopener">http://127.0.0.1:6060/debug/pprof/</a></p><p>/debug/pprof/</p><p>profiles:<br>0   block<br>5   goroutine<br>3   heap<br>0   mutex<br>9   threadcreate</p><p>full goroutine stack dump<br>这个页面中有许多子页面，咱们继续深究下去，看看可以得到什么？</p><p>cpu（CPU Profiling）: $HOST/debug/pprof/profile，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件<br>block（Block Profiling）：$HOST/debug/pprof/block，查看导致阻塞同步的堆栈跟踪<br>goroutine：$HOST/debug/pprof/goroutine，查看当前所有运行的 goroutines 堆栈跟踪<br>heap（Memory Profiling）: $HOST/debug/pprof/heap，查看活动对象的内存分配情况<br>mutex（Mutex Profiling）：$HOST/debug/pprof/mutex，查看导致互斥锁的竞争持有者的堆栈跟踪<br>threadcreate：$HOST/debug/pprof/threadcreate，查看创建新OS线程的堆栈跟踪<br>二、通过交互式终端使用</p><p>profile<br>（1）go tool pprof <a href="http://localhost:6060/debug/pprof/profile?seconds=60" target="_blank" rel="noopener">http://localhost:6060/debug/pprof/profile?seconds=60</a></p><p>$ go tool pprof <a href="http://localhost:6060/debug/pprof/profile\?seconds\=60" target="_blank" rel="noopener">http://localhost:6060/debug/pprof/profile\?seconds\=60</a></p><p>Fetching profile over HTTP from <a href="http://localhost:6060/debug/pprof/profile?seconds=60" target="_blank" rel="noopener">http://localhost:6060/debug/pprof/profile?seconds=60</a><br>Saved profile in /Users/eddycjy/pprof/pprof.samples.cpu.007.pb.gz<br>Type: cpu<br>Duration: 1mins, Total samples = 26.55s (44.15%)<br>Entering interactive mode (type “help” for commands, “o” for options)<br>(pprof)<br>执行该命令后，需等待 60 秒（可调整 seconds 的值），pprof 会进行 CPU Profiling。结束后将默认进入 pprof 的交互式命令模式，可以对分析的结果进行查看或导出。具体可执行 pprof help 查看命令说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top10</span><br><span class="line">Showing nodes accounting for 25.92s, 97.63% of 26.55s total</span><br><span class="line">Dropped 85 nodes (cum &lt;= 0.13s)</span><br><span class="line">Showing top 10 nodes out of 21</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    23.28s 87.68% 87.68%     23.29s 87.72%  syscall.Syscall</span><br><span class="line">     0.77s  2.90% 90.58%      0.77s  2.90%  runtime.memmove</span><br><span class="line">     0.58s  2.18% 92.77%      0.58s  2.18%  runtime.freedefer</span><br><span class="line">     0.53s  2.00% 94.76%      1.42s  5.35%  runtime.scanobject</span><br><span class="line">     0.36s  1.36% 96.12%      0.39s  1.47%  runtime.heapBitsForObject</span><br><span class="line">     0.35s  1.32% 97.44%      0.45s  1.69%  runtime.greyobject</span><br><span class="line">     0.02s 0.075% 97.51%     24.96s 94.01%  main.main.func1</span><br><span class="line">     0.01s 0.038% 97.55%     23.91s 90.06%  os.(*File).Write</span><br><span class="line">     0.01s 0.038% 97.59%      0.19s  0.72%  runtime.mallocgc</span><br><span class="line">     0.01s 0.038% 97.63%     23.30s 87.76%  syscall.Write</span><br><span class="line">flat：给定函数上运行耗时</span><br><span class="line">flat%：同上的 CPU 运行耗时总比例</span><br><span class="line">sum%：给定函数累积使用 CPU 总比例</span><br><span class="line">cum：当前函数加上它之上的调用运行总耗时</span><br><span class="line">cum%：同上的 CPU 运行耗时总比例</span><br><span class="line">最后一列为函数名称，在大多数的情况下，我们可以通过这五列得出一个应用程序的运行情况，加以优化</span><br></pre></td></tr></table></figure></p><p>heap<br>（2）go tool pprof <a href="http://localhost:6060/debug/pprof/heap" target="_blank" rel="noopener">http://localhost:6060/debug/pprof/heap</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go tool pprof http://localhost:6060/debug/pprof/heap</span><br><span class="line">Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap</span><br><span class="line">Saved profile in /Users/eddycjy/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.008.pb.gz</span><br><span class="line">Type: inuse_space</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 837.48MB, 100% of 837.48MB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  837.48MB   100%   100%   837.48MB   100%  main.main.func1</span><br><span class="line">-inuse_space：分析应用程序的常驻内存占用情况</span><br><span class="line"></span><br><span class="line">-alloc_objects：分析应用程序的内存临时分配情况</span><br></pre></td></tr></table></figure></p><p>（3） go tool pprof <a href="http://localhost:6060/debug/pprof/block" target="_blank" rel="noopener">http://localhost:6060/debug/pprof/block</a></p><p>（4） go tool pprof <a href="http://localhost:6060/debug/pprof/mutex" target="_blank" rel="noopener">http://localhost:6060/debug/pprof/mutex</a></p><p>三、PProf 可视化界面<br>这是令人期待的一小节。在这之前，我们需要简单的编写好测试用例来跑一下</p><p>编写测试用例<br>（1）新建 data/d_test.go，文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package data</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">const url = &quot;https://github.com/EDDYCJY&quot;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    s := Add(url)</span><br><span class="line">    if s == &quot;&quot; &#123;</span><br><span class="line">        t.Errorf(&quot;Test.Add error!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkAdd(b *testing.B) &#123;</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        Add(url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）执行测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go test -bench=. -cpuprofile=cpu.prof</span><br><span class="line">pkg: github.com/EDDYCJY/go-pprof-example/data</span><br><span class="line">BenchmarkAdd-4      10000000           187 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/EDDYCJY/go-pprof-example/data    2.300s</span><br><span class="line">-memprofile 也可以了解一下</span><br></pre></td></tr></table></figure></p><p>启动 PProf 可视化界面<br>方法一：<br>$ go tool pprof -http=:8080 cpu.prof<br>方法二：<br>$ go tool pprof cpu.prof<br>$ (pprof) web<br>如果出现 Could not execute dot; may need to install graphviz.，就是提示你要安装 graphviz 了 （请右拐谷歌）</p><p>查看 PProf 可视化界面<br>（1）Top</p><p><img src="/img/top.jpeg" alt="avatar"></p><p>（2）Graph</p><p><img src="/img/graph.jpeg" alt="avatar"></p><p>框越大，线越粗代表它占用的时间越大哦</p><p>（3）Peek</p><p><img src="/img/peek.jpeg" alt="avatar"></p><p>（4）Source</p><p><img src="/img/source.jpeg" alt="avatar"></p><p>通过 PProf 的可视化界面，我们能够更方便、更直观的看到 Go 应用程序的调用链、使用情况等，并且在 View 菜单栏中，还支持如上多种方式的切换</p><p>你想想，在烦恼不知道什么问题的时候，能用这些辅助工具来检测问题，是不是瞬间效率翻倍了呢 👌</p><p>四、PProf 火焰图<br>另一种可视化数据的方法是火焰图，需手动安装原生 PProf 工具：</p><p>（1） 安装 PProf</p><p>$ go get -u github.com/google/pprof<br>（2） 启动 PProf 可视化界面:</p><p>$ pprof -http=:8080 cpu.prof<br>（3） 查看 PProf 可视化界面</p><p>打开 PProf 的可视化界面时，你会明显发现比官方工具链的 PProf 精致一些，并且多了 Flame Graph（火焰图）</p><p>它就是本次的目标之一，它的最大优点是动态的。调用顺序由上到下（A -&gt; B -&gt; C -&gt; D），每一块代表一个函数，越大代表占用 CPU 的时间更长。同时它也支持点击块深入进行分析！</p><p><img src="/img/PProf.jpeg" alt="avatar"></p><p>总结<br>在本章节，粗略地介绍了 Go 的性能利器 PProf。在特定的场景中，PProf 给定位、剖析问题带了极大的帮助</p><p>希望本文对你有所帮助，另外建议能够自己实际操作一遍，最好是可以深入琢磨一下，内含大量的用法、知识点 🤓</p><p>思考题<br>你很优秀的看到了最后，那么有两道简单的思考题，希望拓展你的思路</p><p>（1）flat 一定大于 cum 吗，为什么？什么场景下 cum 会比 flat 大？</p><p>（2）本章节的 demo 代码，有什么性能问题？怎么解决它？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次使用go语言开发iam，接口、logic、manager写了很多，但是从来没有考虑过性能，开发完成后，对另一个小哥的工作很感兴趣，一下大概介绍一下 使用go语言开发项目的性能优化&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>并发模型比较</title>
    <link href="http://yoursite.com/2018/09/18/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2018/09/18/并发模型比较/</id>
    <published>2018-09-17T16:24:27.000Z</published>
    <updated>2018-11-18T11:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>把拖延的对并发模型做一个大概总结<br><a id="more"></a><br>本文参考<a href="https://gobomb.github.io/" target="_blank" rel="noopener">https://gobomb.github.io/</a><br>从一个很久前的具体情况开始，c10k问题：<br>C10k 就是 Client 10000，单机服务器同时服务1万个客户端。当然，现在的业务面临的是 C100k、C1000k 了。早期的服务器是基于进程/线程模型，每新来一个连接，就分配一个进程（线程）去处理这个连接。而进程（线程）在操作系统中，占有一定的资源。由于硬件的限制，进程（线程）的创建是有瓶颈的。另外进程（线程）的上下文切换也有成本：每次调度器调度线程，操作系统都要把线程的各种必要的信息，如程序计数器、堆栈、寄存器、状态等保存起来。</p><p>CPU 运算远远快于 I/O 操作。一般而言，常见的互联网应用（比如 Web）都是 I/O 密集型而非计算密集型。I/O 密集型是指，计算机 CPU 大量的时间都花在等待数据的输入输出，而不是计算。当 CPU 大部分时间都在等待 I/O 的时候，大部分计算资源都被浪费掉了。</p><p>显然，简单粗暴地开一个进程/线程去 handle 一个连接是不够的。为了达到高并发，应该好好考虑一下 I/O 策略。同样的硬件条件下，不同的设计产生的效果差别也会很大。在讨论几种 I/O 模型之前，先介绍一下同步/异步、阻塞/非阻塞的概念，以及操作系统的知识。</p><hr><p>同步/异步？阻塞/非阻塞？<br>同步，是调用者主动去查看调用的状态；异步，则是被调用者来通知调用者。例如在 Web 应用里，后端通过渲染模版的方式把 Web 页面发送给前端，是同步的方式。这里前端是调用者，每一次请求数据，都要把整个页面重新加载一次。而前端用 jQuery Ajex 向服务器请求数据，则是异步的，每次请求数据不需要把整个页面重新加载，局部刷新即可。</p><p>阻塞和非阻塞的区别是调用后是否立即返回。 A 调完 B，就在调用处等待（阻塞），直到 B 方法返回才继续执行剩下的代码，这就是阻塞调用。而非阻塞是 A 方法调用 B 方法，B 方法立即返回，A 可以继续执行下面的代码，不会被该调用阻塞。当某个方法被阻塞了，该方法所在的线程会被挂起，被操作系统的调度器放到阻塞队列，直到 A 等待的事件发生，才从阻塞态转到就绪态。</p><hr><p>进程、线程、协程<br>进程 是系统进行资源分配的一个独立单位。这些资源包括：用户的地址空间，实现进程（线程）间同步和通信的机制，已打开的文件和已申请到的I/O设备，以及一张由核心进程维护的地址映射表。内核通过 进程控制块 （PCB，process control block）来感知进程。</p><p>线程 是调度和分派的基本单位。内核通过 线程控制块 （TCB，thread control block）来感知线程。</p><p>线程本身不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源，如TCB、程序计数器、局部变量、状态参数、返回地址等寄存器和堆栈。同一进程的所有线程具有相同的地址空间，线程可以访问进程拥有的资源。多个线程可并发执行，一个进程含有若干个相对独立的线程，但至少有一个线程。</p><p>线程的有不同的实现方式，分 内核支持线程 （KST，Kernel Supported Threads）和 用户级线程 (UST, User Supported Threads)。内核级线程的 TCB 保存在内核空间，其创建、阻塞、撤销、切换等活动也都是在内核空间实现的。用户级线程则是内核无关的，用户级线程的实现在用户空间，内核感知不到用户线程的存在。用户线程的调度算法可以是进程专用的，不会被内核调度，但同时，用户线程也无法利用多处理机的并行执行。而一个拥有多个用户线程的进程，一旦有一个线程阻塞，该进程所有的线程都会被阻塞。内核的切换需要转换到内核空间，而用户线程不需要，所以前者开销会更大。但用户线程也需要内核的支持，一般是通过运行时系统或内核控制线程来连接一个内核线程，有 1:1、1:n、n:m 的不同实现。</p><p>在分时操作系统中，处理机的调度一般基于时间片的轮转（RR, round robin)，多个就绪线程排成队列，轮流执行时间片。而为保证交互性和实时性，线程都是以抢占的方式（Preemptive Mode）来获得处理机。而抢占方式的开销是比较大的。有抢占方式就有非抢占方式（Nonpreemptiv Mode)，在非抢占式中，除非某正在运行的线程执行完毕、因系统调用（如 I/O 请求）发生阻塞或主动让出处理器，不会被调度或暂停。</p><p>而 协程 （Coroutine）就是基于非抢占式的调度来实现的。进程、线程是操作系统级别的概念，而协程是编译器级别的，现在很多编程语言都支持协程，如 Erlang、Lua、Python、Golang。准确来说，协程只是一种用户态的轻量线程。它运行在用户空间，不受系统调度。它有自己的调度算法。在上下文切换的时候，协程在用户空间切换，而不是陷入内核做线程的切换，减少了开销。简单地理解，就是编译器提供一套自己的运行时系统（而非内核）来做调度，做上下文的保存和恢复，重新实现了一套“并发”机制。系统的并发是时间片的轮转，单处理器交互执行不同的执行流，营造不同线程同时执行的感觉；而协程的并发，是单线程内控制权的轮转。相比抢占式调度，协程是主动让权，实现协作。协程的优势在于，相比回调的方式，写的异步代码可读性更强。缺点在于，因为是用户级线程，利用不了多核机器的并发执行。</p><p>线程的出现，是为了分离进程的两个功能：资源分配和系统调度。让更细粒度、更轻量的线程来承担调度，减轻调度带来的开销。但线程还是不够轻量，因为调度是在内核空间进行的，每次线程切换都需要陷入内核，这个开销还是不可忽视的。协程则是把调度逻辑在用户空间里实现，通过自己（编译器运行时系统/程序员）模拟控制权的交接，来达到更加细粒度的控制。</p><hr><p>并发模型</p><ol><li><p>单进（线）程·循环处理请求<br>单进程和单线程其实没有区别，因为一个进程至少有一个线程。循环处理请求应该是最初级的做法。当大量请求进来时，单线程一个一个处理请求，请求很容易就积压起来，得不到响应。这是无并发的做法。</p></li><li><p>多进程<br>主进程监听和管理连接，当有客户请求的时候，fork 一个子进程来处理连接，父进程继续等待其他客户的请求。但是进程占用服务器资源是比较多的，服务器负载会很高。</p></li></ol><p>Apache 是多进程服务器。有两种模式：</p><p>Prefork MPM : 使用多个子进程，但每个子进程不包含多线程。每个进程只处理一个连接。在许多系统上它的速度和worker MPM一样快，但是需要更多的内存。这种无线程的设计在某些性况下优于 worker MPM，因为它可在应用于不具备线程安全的第三方模块上（如 PHP3/4/5），且在不支持线程调试的平台上易于调试，另外还具有比worker MPM更高的稳定性。</p><p>Worker MPM : 使用多个子进程，每个子进程中又有多个线程。每个线程处理一个请求，该MPM通常对高流量的服务器是一个不错的选择。因为它比prefork MPM需要更少的内存且更具有伸缩性。</p><p>这种架构的最大的好处是隔离性，子进程万一 crash 并不会影响到父进程。缺点就是对系统的负担过重。</p><ol start="3"><li>多线程<br>和多进程的方式类似，只不过是替换成线程。主线程负责监听、accept()连接，子线程（工作线程）负责处理业务逻辑和流的读取。子线程阻塞，同一进程内的其他线程不会被阻塞。</li></ol><p>缺点是：</p><p>会频繁地创建、销毁线程，这对系统也是个不小的开销。这个问题可以用线程池来解决。线程池是预先创建一部分线程，由线程池管理器来负责调度线程，达到线程复用的效果，避免了反复创建线程带来的性能开销，节省了系统的资源。</p><p>要处理同步的问题，当多个线程请求同一个资源时，需要用锁之类的手段来保证线程安全。同步处理不好会影响数据的安全性，也会拉低性能。</p><p>一个线程的崩溃会导致整个进程的崩溃。</p><p>多线程的适用场景是：提高响应速度，让IO和计算相互重叠，降低延时。虽然多线程不能提高绝对性能，但是可以提高平均响应性能。</p><p>这种其实是比较容易想到的，特别是对于刚刚学习多线程和操作系统的计算机学生而言。在请求量不高的时候，是足够的。来多少连接开多少线程，就看服务器的硬件性能能不能承受。但高并发并不是线性地堆砌硬件或加线程数就能达到的。100个线程也许能够达到1000的并发，但10000的并发下，线程数乘以10也许就不行，比如线程调度带来的开销、同步成为了瓶颈。</p><ol start="4"><li>单线程·回调（callback）和事件轮询<br>Nginx 采用的是多进程（单线程） &amp; 多路IO复用模型:</li></ol><p>Nginx 在启动后，会有一个 master 进程和多个相互独立的 worker 进程。</p><p>接收来自外界的信号，向各 worker 进程发送信号，每个进程都有可能来处理这个连接</p><p>master 进程能监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动启动新的 worker 进程。</p><p>主进程（master 进程）首先通过 socket() 来创建一个 sock 文件描述符用来监听，然后fork生成子进程（workers 进程），子进程将继承父进程的 sockfd（socket 文件描述符），之后子进程 accept() 后将创建已连接描述符（connected descriptor）），然后通过已连接描述符来与客户端通信。</p><p>存在惊群现象：当连接进来时，所有子进程都将收到通知并“争着”与它建立连接。</p><p>Nginx 在 accept 上加一把互斥锁来应对惊群现象。</p><p>在每个 worker 进程里，Nginx 调用内核 epoll()函数来实现 I/O 的多路复用。</p><p>Node.js<br>Node.js 也是单线程模型。Node.js中所有的逻辑都是事件的回调函数，所以 Node.js始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数中可能会发出I/O请求或直接发射（ emit ）事件，执行完毕后返回事件循环。事件循环会检查事件队列中有没有未处理的事件，直到程序结束。Node.js的事件循环对开发者不可见，由 libev 库实现，libev 不断检查是否有活动的、可供检测的事件监听器，直到检查不到时才退出事件循环，程序结束。</p><p>Node.js 单线程能够实现非阻塞，是因为其底层实现有另一个线程在轮询事件队列，对于上层的开发者，只需考虑单线程，没有权限去开新的线程，也不需要考虑线程同步之类的问题。</p><p>这种机制的缺点是，会造成大量回调函数的嵌套，代码可读性不佳。因为没有多线程，在多核的机器上，也没办法实现并行执行。</p><ol start="5"><li>协程<br>协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python是在代码里显式地yield进行切换，golang 则是用go语法来开启 goroutine，具体的调度由语言层面提供的运行时执行。</li></ol><p>gorounte 的堆栈比较小，一般是几k，可以动态增长。线程的堆栈空间在 Windows 下默认 2M，Linux 下默认 8M。这也是 goroutine 单机支持上万并发的原因，因为它更廉价。</p><p>从堆栈的角度，进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(内核线程)。协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。</p><p>在使用 goroutine 的时候，可以把它当作轻量级的线程来用，和多进程、多线程方式一样，主 goroutine 监听，开启多个工作 goroutine 处理连接。比起多线程的方式，优势在于能开更多的 goroutine，来处理连接。</p><p>goroutine 的底层实现，关键在于三个基本对象上，G(goroutine)，M(machine)，P (process)。M：与内核线程连接，代表内核线程；P：代表M运行G所需要的资源，可以把它看做一个局部的调度器，维护着一个goroutine队列；G:代表一个goroutine，有自己的栈。M 和 G 的映射，可以类比操作系统内核线程与用户线程的 m:n 模型。通过对 P 数量的控制，可以控制操作系统的并发度。</p><hr><p>Actor 和 CSP 模型<br>传统的多线程编程，是用共享内存的方式来进行同步的。但当并行度变高，不确定性就增加了，需要用锁等机制保证正确性，但锁用得不好容易拉低性能。而且多线程编程也是比较困难的，不太符合人的思维习惯，很容易出错，会产生死锁。所以有一些新的编程模型来实现高并发，用消息传递来代替共享内存和锁。</p><p>于是就有了“Don’t communicate by sharing memory, share memory by communicating”（不要通过共享内存来通信，而应该通过通信来共享内存）的思想，Actor 和 CSP 就是两种基于这种思想的并发编程模型，学术界已有诸多论文加以阐述。也就是说，这是有数学证明的，了解这两种模型，能给高并发服务器的开发很多有益的启发。作为工程师，不一定要有理论创新，但要学会把理论成果用到自己的项目上面。</p><p>「Actor 模型的重点在于参与交流的实体,而 CSP 模型的重点在于用于交流的通道。」Java/Scala 有个库 akka，就是 Actor 模型的实现。而 golang 的协程机制则是 CSP 模型。</p><p>「Actor 模型推崇的哲学是“一切皆是参与者(actor)”，这与面向对象编程的“一切皆是对象”类似。」「Actor模型=数据+行为+消息。Actor模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证Actor内部数据只有被自己修改。」</p><p>我的理解是，在模型内部，对数据的处理始终是单线程的，所以无需要考虑线程安全，无需加锁，外部可以是多线程，要操作数据需要向内部线程发送消息，内部线程一次只处理一次消息，一个消息代表一个处理数据的行为。内部线程和外部线程通过信箱（mailbox）来实现异步的消息机制。</p><p>CSP 与 Actor 类似，process（在 go 中则是 goroutine） 对应 acotor，也就是发送消息的实体。 channel 对应 mailbox，是传递消息的载体。区别在与一个 actor 只有一个 mailbox，actor 和 mailbox 是耦合的。channel 是作为 first-class 独立存在的（这在 golang 中很明显），channel 是匿名的。mailbox 是异步的，channel 一般是同步的（在 golang 里，channel 有同步模式，也可以设置缓冲区大小实现异步）。</p><hr><p>总结<br>高并发的关键在于实现异步非阻塞，更加高效地利用 CPU。多线程可以达到非阻塞，但占用资源多，切换开销大。协程用栈的动态增长、用户态的调度来避免多线程的两个问题。事件驱动用单线程的方式，避免了占用太多系统资源，不需要关心线程安全，但无法利用多核。具体要采用哪种模型，还是要看需求。模型或技术只是工具，条条大陆通罗马。</p><p>比较优雅的还是 CSP 和 Actor 模型，因为能够符合人的思维习惯，避免了锁的使用。个人觉得加锁和多线程的方式，很容易被滥用，这是一种从微观出发和线性的思维方式，不够高屋建瓴。不如用消息通信来的耦合性更低。</p><p>高并发编程很有必要性。一方面，很多应用都需要高并发支持，网络的用户越来越多，业务场景会越来越复杂，需要有稳定和高效的服务器支持。另一方面，现代的计算机性能都是比较高的，但如果软件设计得不够好，就不能够把性能都给发挥出来。这就很浪费了。</p><p>在写这篇文章的时候，我发现了很多有趣的开源源码和项目，值得进一步研究和阅读，但时间有限，暂时没有深入。接下来会继续了解一下，然后更新一些文章：</p><p>libtask golang 作者之一 Russ Cox 实现的 C 语言协程库，golang 的 goroutine 就参考了这个库的实现： <a href="https://swtch.com/libtask/" target="_blank" rel="noopener">https://swtch.com/libtask/</a></p><p>libev 事件驱动编程框架：<a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="noopener">http://software.schmorp.de/pkg/libev.html</a></p><p>akka scala 实现的 Actor 框架：<a href="https://akka.io/" target="_blank" rel="noopener">https://akka.io/</a></p><hr><p>update：函数式编程<br>2018.01.01</p><p>最近了解到，函数式编程也是一个可以用来解决并发问题的模型。</p><p>命令式语言和函数式语言的抽象不同。</p><p>命令式编程是对计算机硬件的抽象，关心的是解决问题的步骤。函数式编程是对数学的抽象，把问题转化为数学表达式。</p><p>函数性语言两个特征：数据不可变，不依赖保存或检索状态的操；无副作用，用相同的输入调用函数，总是返回相同的值。也因此，可以不依赖锁来做并发编程。</p><p>还没有学习函数式的语言，所以对函数式编程如何做到并发不是很理解。但能感受到，函数式语言是一个值得探寻的领域。</p><p>有一句话“软件的首要技术使命是管理复杂度。”（《代码大全》）。之所以存在这么多抽象，一方面是要有效地解决问题，另一方面，也是为了降低程序员的心智负担。编程模型其实就是程序员看待问题的方式。同样解决问题，当然是选择编程友好、符合人的思维习惯的编程模型比较好。“代码是写给人看的,不是写给机器看的”（SICP）。虽然机器一样能执行，但最终的目的是为了解放人，让人能把大部分精力花在刀刃上、花在创造性的工作上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把拖延的对并发模型做一个大概总结&lt;br&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
